{"ast":null,"code":"import _toConsumableArray from \"C:/Users/pk117/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/pk117/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/pk117/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"autoplay\", \"delay\", \"driver\", \"keyframes\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\", \"onPlay\", \"onStop\", \"onComplete\", \"onUpdate\"];\nimport { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorDuration } from '../../generators/utils/calc-duration.mjs';\nimport { invariant } from '../../../utils/errors.mjs';\nvar types = {\n  decay: inertia,\n  inertia: inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring: spring\n};\n/**\r\n * Animate a single value on the main thread.\r\n *\r\n * This function is written, where functionality overlaps,\r\n * to be largely spec-compliant with WAAPI to allow fungibility\r\n * between the two.\r\n */\nfunction animateValue(_ref) {\n  var _ref$autoplay = _ref.autoplay,\n    autoplay = _ref$autoplay === void 0 ? true : _ref$autoplay,\n    _ref$delay = _ref.delay,\n    delay = _ref$delay === void 0 ? 0 : _ref$delay,\n    _ref$driver = _ref.driver,\n    driver = _ref$driver === void 0 ? frameloopDriver : _ref$driver,\n    keyframes$1 = _ref.keyframes,\n    _ref$type = _ref.type,\n    type = _ref$type === void 0 ? \"keyframes\" : _ref$type,\n    _ref$repeat = _ref.repeat,\n    repeat = _ref$repeat === void 0 ? 0 : _ref$repeat,\n    _ref$repeatDelay = _ref.repeatDelay,\n    repeatDelay = _ref$repeatDelay === void 0 ? 0 : _ref$repeatDelay,\n    _ref$repeatType = _ref.repeatType,\n    repeatType = _ref$repeatType === void 0 ? \"loop\" : _ref$repeatType,\n    onPlay = _ref.onPlay,\n    onStop = _ref.onStop,\n    onComplete = _ref.onComplete,\n    onUpdate = _ref.onUpdate,\n    options = _objectWithoutProperties(_ref, _excluded);\n  var speed = 1;\n  var hasStopped = false;\n  var resolveFinishedPromise;\n  var currentFinishedPromise;\n  /**\r\n   * Resolve the current Promise every time we enter the\r\n   * finished state. This is WAAPI-compatible behaviour.\r\n   */\n  var updateFinishedPromise = function updateFinishedPromise() {\n    currentFinishedPromise = new Promise(function (resolve) {\n      resolveFinishedPromise = resolve;\n    });\n  };\n  // Create the first finished promise\n  updateFinishedPromise();\n  var animationDriver;\n  var generatorFactory = types[type] || keyframes;\n  /**\r\n   * If this isn't the keyframes generator and we've been provided\r\n   * strings as keyframes, we need to interpolate these.\r\n   */\n  var mapNumbersToKeyframes;\n  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n    if (process.env.NODE_ENV !== \"production\") {\n      invariant(keyframes$1.length === 2, \"Only two keyframes currently supported with spring and inertia animations. Trying to animate \".concat(keyframes$1));\n    }\n    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  var generator = generatorFactory(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes: keyframes$1\n  }));\n  var mirroredGenerator;\n  if (repeatType === \"mirror\") {\n    mirroredGenerator = generatorFactory(_objectSpread(_objectSpread({}, options), {}, {\n      keyframes: _toConsumableArray(keyframes$1).reverse(),\n      velocity: -(options.velocity || 0)\n    }));\n  }\n  var playState = \"idle\";\n  var holdTime = null;\n  var startTime = null;\n  var cancelTime = null;\n  /**\r\n   * If duration is undefined and we have repeat options,\r\n   * we need to calculate a duration from the generator.\r\n   *\r\n   * We set it to the generator itself to cache the duration.\r\n   * Any timeline resolver will need to have already precalculated\r\n   * the duration by this step.\r\n   */\n  if (generator.calculatedDuration === null && repeat) {\n    generator.calculatedDuration = calcGeneratorDuration(generator);\n  }\n  var calculatedDuration = generator.calculatedDuration;\n  var resolvedDuration = Infinity;\n  var totalDuration = Infinity;\n  if (calculatedDuration !== null) {\n    resolvedDuration = calculatedDuration + repeatDelay;\n    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n  }\n  var currentTime = 0;\n  var tick = function tick(timestamp) {\n    if (startTime === null) return;\n    /**\r\n     * requestAnimationFrame timestamps can come through as lower than\r\n     * the startTime as set by performance.now(). Here we prevent this,\r\n     * though in the future it could be possible to make setting startTime\r\n     * a pending operation that gets resolved here.\r\n     */\n    if (speed > 0) startTime = Math.min(startTime, timestamp);\n    if (speed < 0) startTime = Math.min(timestamp - totalDuration / speed, startTime);\n    if (holdTime !== null) {\n      currentTime = holdTime;\n    } else {\n      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n      // example.\n      currentTime = Math.round(timestamp - startTime) * speed;\n    }\n    // Rebase on delay\n    var timeWithoutDelay = currentTime - delay * (speed >= 0 ? 1 : -1);\n    var isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    currentTime = Math.max(timeWithoutDelay, 0);\n    /**\r\n     * If this animation has finished, set the current time\r\n     * to the total duration.\r\n     */\n    if (playState === \"finished\" && holdTime === null) {\n      currentTime = totalDuration;\n    }\n    var elapsed = currentTime;\n    var frameGenerator = generator;\n    if (repeat) {\n      /**\r\n       * Get the current progress (0-1) of the animation. If t is >\r\n       * than duration we'll get values like 2.5 (midway through the\r\n       * third iteration)\r\n       */\n      var progress = Math.min(currentTime, totalDuration) / resolvedDuration;\n      /**\r\n       * Get the current iteration (0 indexed). For instance the floor of\r\n       * 2.5 is 2.\r\n       */\n      var currentIteration = Math.floor(progress);\n      /**\r\n       * Get the current progress of the iteration by taking the remainder\r\n       * so 2.5 is 0.5 through iteration 2\r\n       */\n      var iterationProgress = progress % 1.0;\n      /**\r\n       * If iteration progress is 1 we count that as the end\r\n       * of the previous iteration.\r\n       */\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\r\n       * Reverse progress if we're not running in \"normal\" direction\r\n       */\n      var isOddIteration = Boolean(currentIteration % 2);\n      if (isOddIteration) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n    }\n    /**\r\n     * If we're in negative time, set state as the initial keyframe.\r\n     * This prevents delay: x, duration: 0 animations from finishing\r\n     * instantly.\r\n     */\n    var state = isInDelayPhase ? {\n      done: false,\n      value: keyframes$1[0]\n    } : frameGenerator.next(elapsed);\n    if (mapNumbersToKeyframes) {\n      state.value = mapNumbersToKeyframes(state.value);\n    }\n    var done = state.done;\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;\n    }\n    var isAnimationFinished = holdTime === null && (playState === \"finished\" || playState === \"running\" && done);\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n    if (isAnimationFinished) {\n      finish();\n    }\n    return state;\n  };\n  var stopAnimationDriver = function stopAnimationDriver() {\n    animationDriver && animationDriver.stop();\n    animationDriver = undefined;\n  };\n  var _cancel = function cancel() {\n    playState = \"idle\";\n    stopAnimationDriver();\n    resolveFinishedPromise();\n    updateFinishedPromise();\n    startTime = cancelTime = null;\n  };\n  var finish = function finish() {\n    playState = \"finished\";\n    onComplete && onComplete();\n    stopAnimationDriver();\n    resolveFinishedPromise();\n  };\n  var play = function play() {\n    if (hasStopped) return;\n    if (!animationDriver) animationDriver = driver(tick);\n    var now = animationDriver.now();\n    onPlay && onPlay();\n    if (holdTime !== null) {\n      startTime = now - holdTime;\n    } else if (!startTime || playState === \"finished\") {\n      startTime = now;\n    }\n    if (playState === \"finished\") {\n      updateFinishedPromise();\n    }\n    cancelTime = startTime;\n    holdTime = null;\n    /**\r\n     * Set playState to running only after we've used it in\r\n     * the previous logic.\r\n     */\n    playState = \"running\";\n    animationDriver.start();\n  };\n  if (autoplay) {\n    play();\n  }\n  var controls = {\n    then: function then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n    get time() {\n      return millisecondsToSeconds(currentTime);\n    },\n    set time(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      currentTime = newTime;\n      if (holdTime !== null || !animationDriver || speed === 0) {\n        holdTime = newTime;\n      } else {\n        startTime = animationDriver.now() - newTime / speed;\n      }\n    },\n    get duration() {\n      var duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;\n      return millisecondsToSeconds(duration);\n    },\n    get speed() {\n      return speed;\n    },\n    set speed(newSpeed) {\n      if (newSpeed === speed || !animationDriver) return;\n      speed = newSpeed;\n      controls.time = millisecondsToSeconds(currentTime);\n    },\n    get state() {\n      return playState;\n    },\n    play: play,\n    pause: function pause() {\n      playState = \"paused\";\n      holdTime = currentTime;\n    },\n    stop: function stop() {\n      hasStopped = true;\n      if (playState === \"idle\") return;\n      playState = \"idle\";\n      onStop && onStop();\n      _cancel();\n    },\n    cancel: function cancel() {\n      if (cancelTime !== null) tick(cancelTime);\n      _cancel();\n    },\n    complete: function complete() {\n      playState = \"finished\";\n    },\n    sample: function sample(elapsed) {\n      startTime = 0;\n      return tick(elapsed);\n    }\n  };\n  return controls;\n}\nexport { animateValue };","map":{"version":3,"names":["keyframes","spring","inertia","frameloopDriver","interpolate","clamp","millisecondsToSeconds","secondsToMilliseconds","calcGeneratorDuration","invariant","types","decay","tween","animateValue","_ref","_ref$autoplay","autoplay","_ref$delay","delay","_ref$driver","driver","keyframes$1","_ref$type","type","_ref$repeat","repeat","_ref$repeatDelay","repeatDelay","_ref$repeatType","repeatType","onPlay","onStop","onComplete","onUpdate","options","_objectWithoutProperties","_excluded","speed","hasStopped","resolveFinishedPromise","currentFinishedPromise","updateFinishedPromise","Promise","resolve","animationDriver","generatorFactory","mapNumbersToKeyframes","process","env","NODE_ENV","length","concat","generator","_objectSpread","mirroredGenerator","_toConsumableArray","reverse","velocity","playState","holdTime","startTime","cancelTime","calculatedDuration","resolvedDuration","Infinity","totalDuration","currentTime","tick","timestamp","Math","min","round","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","state","done","value","next","isAnimationFinished","finish","stopAnimationDriver","stop","undefined","cancel","play","now","start","controls","then","reject","time","newTime","duration","newSpeed","pause","complete","sample"],"sources":["C:/Users/pk117/Desktop/Personal/pro10150.github.io/node_modules/framer-motion/dist/es/animation/animators/js/index.mjs"],"sourcesContent":["import { keyframes } from '../../generators/keyframes.mjs';\r\nimport { spring } from '../../generators/spring/index.mjs';\r\nimport { inertia } from '../../generators/inertia.mjs';\r\nimport { frameloopDriver } from './driver-frameloop.mjs';\r\nimport { interpolate } from '../../../utils/interpolate.mjs';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\r\nimport { calcGeneratorDuration } from '../../generators/utils/calc-duration.mjs';\r\nimport { invariant } from '../../../utils/errors.mjs';\r\n\r\nconst types = {\r\n    decay: inertia,\r\n    inertia,\r\n    tween: keyframes,\r\n    keyframes: keyframes,\r\n    spring,\r\n};\r\n/**\r\n * Animate a single value on the main thread.\r\n *\r\n * This function is written, where functionality overlaps,\r\n * to be largely spec-compliant with WAAPI to allow fungibility\r\n * between the two.\r\n */\r\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\r\n    let speed = 1;\r\n    let hasStopped = false;\r\n    let resolveFinishedPromise;\r\n    let currentFinishedPromise;\r\n    /**\r\n     * Resolve the current Promise every time we enter the\r\n     * finished state. This is WAAPI-compatible behaviour.\r\n     */\r\n    const updateFinishedPromise = () => {\r\n        currentFinishedPromise = new Promise((resolve) => {\r\n            resolveFinishedPromise = resolve;\r\n        });\r\n    };\r\n    // Create the first finished promise\r\n    updateFinishedPromise();\r\n    let animationDriver;\r\n    const generatorFactory = types[type] || keyframes;\r\n    /**\r\n     * If this isn't the keyframes generator and we've been provided\r\n     * strings as keyframes, we need to interpolate these.\r\n     */\r\n    let mapNumbersToKeyframes;\r\n    if (generatorFactory !== keyframes &&\r\n        typeof keyframes$1[0] !== \"number\") {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\r\n        }\r\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\r\n            clamp: false,\r\n        });\r\n        keyframes$1 = [0, 100];\r\n    }\r\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\r\n    let mirroredGenerator;\r\n    if (repeatType === \"mirror\") {\r\n        mirroredGenerator = generatorFactory({\r\n            ...options,\r\n            keyframes: [...keyframes$1].reverse(),\r\n            velocity: -(options.velocity || 0),\r\n        });\r\n    }\r\n    let playState = \"idle\";\r\n    let holdTime = null;\r\n    let startTime = null;\r\n    let cancelTime = null;\r\n    /**\r\n     * If duration is undefined and we have repeat options,\r\n     * we need to calculate a duration from the generator.\r\n     *\r\n     * We set it to the generator itself to cache the duration.\r\n     * Any timeline resolver will need to have already precalculated\r\n     * the duration by this step.\r\n     */\r\n    if (generator.calculatedDuration === null && repeat) {\r\n        generator.calculatedDuration = calcGeneratorDuration(generator);\r\n    }\r\n    const { calculatedDuration } = generator;\r\n    let resolvedDuration = Infinity;\r\n    let totalDuration = Infinity;\r\n    if (calculatedDuration !== null) {\r\n        resolvedDuration = calculatedDuration + repeatDelay;\r\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\r\n    }\r\n    let currentTime = 0;\r\n    const tick = (timestamp) => {\r\n        if (startTime === null)\r\n            return;\r\n        /**\r\n         * requestAnimationFrame timestamps can come through as lower than\r\n         * the startTime as set by performance.now(). Here we prevent this,\r\n         * though in the future it could be possible to make setting startTime\r\n         * a pending operation that gets resolved here.\r\n         */\r\n        if (speed > 0)\r\n            startTime = Math.min(startTime, timestamp);\r\n        if (speed < 0)\r\n            startTime = Math.min(timestamp - totalDuration / speed, startTime);\r\n        if (holdTime !== null) {\r\n            currentTime = holdTime;\r\n        }\r\n        else {\r\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\r\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\r\n            // example.\r\n            currentTime = Math.round(timestamp - startTime) * speed;\r\n        }\r\n        // Rebase on delay\r\n        const timeWithoutDelay = currentTime - delay * (speed >= 0 ? 1 : -1);\r\n        const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\r\n        currentTime = Math.max(timeWithoutDelay, 0);\r\n        /**\r\n         * If this animation has finished, set the current time\r\n         * to the total duration.\r\n         */\r\n        if (playState === \"finished\" && holdTime === null) {\r\n            currentTime = totalDuration;\r\n        }\r\n        let elapsed = currentTime;\r\n        let frameGenerator = generator;\r\n        if (repeat) {\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = Math.min(currentTime, totalDuration) / resolvedDuration;\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            iterationProgress === 1 && currentIteration--;\r\n            currentIteration = Math.min(currentIteration, repeat + 1);\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const isOddIteration = Boolean(currentIteration % 2);\r\n            if (isOddIteration) {\r\n                if (repeatType === \"reverse\") {\r\n                    iterationProgress = 1 - iterationProgress;\r\n                    if (repeatDelay) {\r\n                        iterationProgress -= repeatDelay / resolvedDuration;\r\n                    }\r\n                }\r\n                else if (repeatType === \"mirror\") {\r\n                    frameGenerator = mirroredGenerator;\r\n                }\r\n            }\r\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\r\n        }\r\n        /**\r\n         * If we're in negative time, set state as the initial keyframe.\r\n         * This prevents delay: x, duration: 0 animations from finishing\r\n         * instantly.\r\n         */\r\n        const state = isInDelayPhase\r\n            ? { done: false, value: keyframes$1[0] }\r\n            : frameGenerator.next(elapsed);\r\n        if (mapNumbersToKeyframes) {\r\n            state.value = mapNumbersToKeyframes(state.value);\r\n        }\r\n        let { done } = state;\r\n        if (!isInDelayPhase && calculatedDuration !== null) {\r\n            done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;\r\n        }\r\n        const isAnimationFinished = holdTime === null &&\r\n            (playState === \"finished\" || (playState === \"running\" && done));\r\n        if (onUpdate) {\r\n            onUpdate(state.value);\r\n        }\r\n        if (isAnimationFinished) {\r\n            finish();\r\n        }\r\n        return state;\r\n    };\r\n    const stopAnimationDriver = () => {\r\n        animationDriver && animationDriver.stop();\r\n        animationDriver = undefined;\r\n    };\r\n    const cancel = () => {\r\n        playState = \"idle\";\r\n        stopAnimationDriver();\r\n        resolveFinishedPromise();\r\n        updateFinishedPromise();\r\n        startTime = cancelTime = null;\r\n    };\r\n    const finish = () => {\r\n        playState = \"finished\";\r\n        onComplete && onComplete();\r\n        stopAnimationDriver();\r\n        resolveFinishedPromise();\r\n    };\r\n    const play = () => {\r\n        if (hasStopped)\r\n            return;\r\n        if (!animationDriver)\r\n            animationDriver = driver(tick);\r\n        const now = animationDriver.now();\r\n        onPlay && onPlay();\r\n        if (holdTime !== null) {\r\n            startTime = now - holdTime;\r\n        }\r\n        else if (!startTime || playState === \"finished\") {\r\n            startTime = now;\r\n        }\r\n        if (playState === \"finished\") {\r\n            updateFinishedPromise();\r\n        }\r\n        cancelTime = startTime;\r\n        holdTime = null;\r\n        /**\r\n         * Set playState to running only after we've used it in\r\n         * the previous logic.\r\n         */\r\n        playState = \"running\";\r\n        animationDriver.start();\r\n    };\r\n    if (autoplay) {\r\n        play();\r\n    }\r\n    const controls = {\r\n        then(resolve, reject) {\r\n            return currentFinishedPromise.then(resolve, reject);\r\n        },\r\n        get time() {\r\n            return millisecondsToSeconds(currentTime);\r\n        },\r\n        set time(newTime) {\r\n            newTime = secondsToMilliseconds(newTime);\r\n            currentTime = newTime;\r\n            if (holdTime !== null || !animationDriver || speed === 0) {\r\n                holdTime = newTime;\r\n            }\r\n            else {\r\n                startTime = animationDriver.now() - newTime / speed;\r\n            }\r\n        },\r\n        get duration() {\r\n            const duration = generator.calculatedDuration === null\r\n                ? calcGeneratorDuration(generator)\r\n                : generator.calculatedDuration;\r\n            return millisecondsToSeconds(duration);\r\n        },\r\n        get speed() {\r\n            return speed;\r\n        },\r\n        set speed(newSpeed) {\r\n            if (newSpeed === speed || !animationDriver)\r\n                return;\r\n            speed = newSpeed;\r\n            controls.time = millisecondsToSeconds(currentTime);\r\n        },\r\n        get state() {\r\n            return playState;\r\n        },\r\n        play,\r\n        pause: () => {\r\n            playState = \"paused\";\r\n            holdTime = currentTime;\r\n        },\r\n        stop: () => {\r\n            hasStopped = true;\r\n            if (playState === \"idle\")\r\n                return;\r\n            playState = \"idle\";\r\n            onStop && onStop();\r\n            cancel();\r\n        },\r\n        cancel: () => {\r\n            if (cancelTime !== null)\r\n                tick(cancelTime);\r\n            cancel();\r\n        },\r\n        complete: () => {\r\n            playState = \"finished\";\r\n        },\r\n        sample: (elapsed) => {\r\n            startTime = 0;\r\n            return tick(elapsed);\r\n        },\r\n    };\r\n    return controls;\r\n}\r\n\r\nexport { animateValue };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}