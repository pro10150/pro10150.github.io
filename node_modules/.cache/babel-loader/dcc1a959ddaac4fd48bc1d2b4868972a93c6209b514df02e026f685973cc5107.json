{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/pk117/Desktop/Personal/pro10150.github.io/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"register\"],\n  _excluded2 = [\"onPress\", \"onPressChange\", \"onPressStart\", \"onPressEnd\", \"onPressUp\", \"isDisabled\", \"isPressed\", \"preventFocusOnPress\", \"shouldCancelOnPointerExit\", \"allowTextSelectionOnPress\", \"ref\"];\nimport { PressResponderContext } from \"./chunk-4XDBEIOV.mjs\";\nimport { PressEvent } from \"./chunk-7OGZUKMH.mjs\";\nimport { disableTextSelection, restoreTextSelection } from \"./chunk-CWMPADA3.mjs\";\nimport { getOwnerDocument, getOwnerWindow } from \"./chunk-FFBWCXWK.mjs\";\nimport \"./chunk-7D66DBGQ.mjs\";\n\n// src/index.ts\nimport { focusWithoutScrolling, isMac, isVirtualClick, isVirtualPointerEvent, mergeProps, openLink, useEffectEvent, useGlobalListeners, useSyncRef } from \"@react-aria/utils\";\nimport { useContext, useEffect, useMemo, useRef, useState } from \"react\";\nfunction usePressResponderContext(props) {\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let {\n        register\n      } = context,\n      contextProps = _objectWithoutProperties(context, _excluded);\n    props = mergeProps(contextProps, props);\n    register();\n  }\n  useSyncRef(context, props.ref);\n  return props;\n}\nvar LINK_CLICKED = Symbol(\"linkClicked\");\nfunction usePress(props) {\n  let _usePressResponderCon = usePressResponderContext(props),\n    {\n      onPress,\n      onPressChange,\n      onPressStart,\n      onPressEnd,\n      onPressUp,\n      isDisabled,\n      isPressed: isPressedProp,\n      preventFocusOnPress,\n      shouldCancelOnPointerExit,\n      allowTextSelectionOnPress,\n      ref: _\n    } = _usePressResponderCon,\n    domProps = _objectWithoutProperties(_usePressResponderCon, _excluded2);\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    ignoreClickAfterPress: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null\n  });\n  let {\n    addGlobalListener,\n    removeAllGlobalListeners\n  } = useGlobalListeners();\n  let triggerPressStart = useEffectEvent((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return;\n    }\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent(\"pressstart\", pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) {\n      onPressChange(true);\n    }\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n  let triggerPressEnd = useEffectEvent(function (originalEvent, pointerType) {\n    let wasPressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let state = ref.current;\n    if (!state.didFirePressStart) {\n      return;\n    }\n    state.ignoreClickAfterPress = true;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new PressEvent(\"pressend\", pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) {\n      onPressChange(false);\n    }\n    setPressed(false);\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new PressEvent(\"press\", pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n    }\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n  let triggerPressUp = useEffectEvent((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return;\n    }\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent(\"pressup\", pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n    return true;\n  });\n  let cancel = useEffectEvent(e => {\n    let state = ref.current;\n    if (state.isPressed) {\n      if (state.isOverTarget && state.target) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress && state.target) {\n        restoreTextSelection(state.target);\n      }\n    }\n  });\n  let cancelOnPointerExit = useEffectEvent(e => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps2 = {\n      onKeyDown(e) {\n        var _a;\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n          if (shouldPreventDefaultKeyboard(e.target, e.key)) {\n            e.preventDefault();\n          }\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            shouldStopPropagation = triggerPressStart(e, \"keyboard\");\n            addGlobalListener(getOwnerDocument(e.currentTarget), \"keyup\", onKeyUp, false);\n          }\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n          if (e.metaKey && isMac()) {\n            (_a = state.metaKeyEvents) == null ? void 0 : _a.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === \"Meta\") {\n          state.metaKeyEvents = /* @__PURE__ */new Map();\n        }\n      },\n      onKeyUp(e) {\n        if (state.target && isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) {\n          triggerPressUp(createEvent(state.target, e), \"keyboard\");\n        }\n      },\n      onClick(e) {\n        if (e && !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (e && e.button === 0 && !state.isTriggeringEvent && !openLink.isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || isVirtualClick(e.nativeEvent))) {\n            if (!isDisabled && !preventFocusOnPress) {\n              focusWithoutScrolling(e.currentTarget);\n            }\n            let stopPressStart = triggerPressStart(e, \"virtual\");\n            let stopPressUp = triggerPressUp(e, \"virtual\");\n            let stopPressEnd = triggerPressEnd(e, \"virtual\");\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          }\n          state.ignoreEmulatedMouseEvents = false;\n          state.ignoreClickAfterPress = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n    let onKeyUp = e => {\n      var _a, _b;\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(e.target, e.key)) {\n          e.preventDefault();\n        }\n        let target = e.target;\n        let shouldStopPropagation = triggerPressEnd(createEvent(state.target, e), \"keyboard\", state.target.contains(target));\n        removeAllGlobalListeners();\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        if (e.key !== \"Enter\" && isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[LINK_CLICKED]) {\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n        state.isPressed = false;\n        (_a = state.metaKeyEvents) == null ? void 0 : _a.delete(e.key);\n      } else if (e.key === \"Meta\" && ((_b = state.metaKeyEvents) == null ? void 0 : _b.size)) {\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = null;\n        for (let event of events.values()) {\n          state.target && state.target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\n        }\n      }\n    };\n    if (typeof PointerEvent !== \"undefined\") {\n      pressProps2.onPointerDown = e => {\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = \"virtual\";\n          return;\n        }\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n        state.pointerType = e.pointerType;\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n          if (!isDisabled && !preventFocusOnPress) {\n            focusWithoutScrolling(e.currentTarget);\n          }\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointermove\", onPointerMove, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointerup\", onPointerUp, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointercancel\", onPointerCancel, false);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseDown = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (e.button === 0) {\n          if (shouldPreventDefault(e.currentTarget)) {\n            e.preventDefault();\n          }\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onPointerUp = e => {\n        if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") {\n          return;\n        }\n        if (e.button === 0 && isOverTarget(e, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n      let onPointerMove = e => {\n        if (e.pointerId !== state.activePointerId || !state.target) {\n          return;\n        }\n        if (isOverTarget(e, state.target)) {\n          if (!state.isOverTarget) {\n            state.isOverTarget = true;\n            triggerPressStart(createEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.isOverTarget) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n      let onPointerUp = e => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (isOverTarget(e, state.target)) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          } else if (state.isOverTarget) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          }\n          state.isPressed = false;\n          state.isOverTarget = false;\n          state.activePointerId = null;\n          state.pointerType = null;\n          removeAllGlobalListeners();\n          if (!allowTextSelectionOnPress) {\n            restoreTextSelection(state.target);\n          }\n        }\n      };\n      let onPointerCancel = e => {\n        cancel(e);\n      };\n      pressProps2.onDragStart = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        cancel(e);\n      };\n    } else {\n      pressProps2.onMouseDown = e => {\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? \"virtual\" : \"mouse\";\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        addGlobalListener(getOwnerDocument(e.currentTarget), \"mouseup\", onMouseUp, false);\n      };\n      pressProps2.onMouseEnter = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseLeave = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseUp = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {\n          triggerPressUp(e, state.pointerType || \"mouse\");\n        }\n      };\n      let onMouseUp = e => {\n        if (e.button !== 0) {\n          return;\n        }\n        state.isPressed = false;\n        removeAllGlobalListeners();\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n        if (!state.target) {\n          return;\n        }\n        if (isOverTarget(e, state.target)) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType);\n        } else if (state.isOverTarget) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n        }\n        state.isOverTarget = false;\n      };\n      pressProps2.onTouchStart = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = \"touch\";\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        addGlobalListener(getOwnerWindow(e.currentTarget), \"scroll\", onScroll, true);\n      };\n      pressProps2.onTouchMove = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          }\n        } else if (state.isOverTarget) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onTouchEnd = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType);\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n        } else if (state.isOverTarget) {\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (!allowTextSelectionOnPress && state.target) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n      pressProps2.onTouchCancel = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(e);\n        }\n      };\n      let onScroll = e => {\n        if (state.isPressed && e.target.contains(state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n      pressProps2.onDragStart = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        cancel(e);\n      };\n    }\n    return pressProps2;\n  }, [addGlobalListener, isDisabled, preventFocusOnPress, removeAllGlobalListeners, allowTextSelectionOnPress, cancel, cancelOnPointerExit, triggerPressEnd, triggerPressStart, triggerPressUp]);\n  useEffect(() => {\n    return () => {\n      if (!allowTextSelectionOnPress && ref.current.target) {\n        restoreTextSelection(ref.current.target);\n      }\n    };\n  }, [allowTextSelectionOnPress]);\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps)\n  };\n}\nfunction isHTMLAnchorLink(target) {\n  return target.tagName === \"A\" && target.hasAttribute(\"href\");\n}\nfunction isValidKeyboardEvent(event, currentTarget) {\n  const {\n    key,\n    code\n  } = event;\n  const element = currentTarget;\n  const role = element.getAttribute(\"role\");\n  return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key) || element instanceof getOwnerWindow(element).HTMLTextAreaElement || element.isContentEditable) && !((role === \"link\" || !role && isHTMLAnchorLink(element)) && key !== \"Enter\");\n}\nfunction getTouchFromEvent(event) {\n  const {\n    targetTouches\n  } = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\nfunction getTouchById(event, pointerId) {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\nfunction createEvent(target, e) {\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey\n  };\n}\nfunction getPointClientRect(point) {\n  let offsetX = !!point.width ? point.width / 2 : point.radiusX || 0;\n  let offsetY = !!point.height ? point.height / 2 : point.radiusY || 0;\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\nfunction areRectanglesOverlapping(a, b) {\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\nfunction isOverTarget(point, target) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\nfunction shouldPreventDefault(target) {\n  return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\n}\nfunction shouldPreventDefaultKeyboard(target, key) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== \"submit\" && target.type !== \"reset\";\n  }\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n  return true;\n}\nvar nonTextInputTypes = /* @__PURE__ */new Set([\"checkbox\", \"radio\", \"range\", \"color\", \"file\", \"image\", \"button\", \"submit\", \"reset\"]);\nfunction isValidInputKey(target, key) {\n  return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : nonTextInputTypes.has(target.type);\n}\nexport { usePress };","map":{"version":3,"names":["PressResponderContext","PressEvent","disableTextSelection","restoreTextSelection","getOwnerDocument","getOwnerWindow","focusWithoutScrolling","isMac","isVirtualClick","isVirtualPointerEvent","mergeProps","openLink","useEffectEvent","useGlobalListeners","useSyncRef","useContext","useEffect","useMemo","useRef","useState","usePressResponderContext","props","context","register","contextProps","_objectWithoutProperties","_excluded","ref","LINK_CLICKED","Symbol","usePress","_usePressResponderCon","onPress","onPressChange","onPressStart","onPressEnd","onPressUp","isDisabled","isPressed","isPressedProp","preventFocusOnPress","shouldCancelOnPointerExit","allowTextSelectionOnPress","_","domProps","_excluded2","setPressed","ignoreEmulatedMouseEvents","ignoreClickAfterPress","didFirePressStart","isTriggeringEvent","activePointerId","target","isOverTarget","pointerType","addGlobalListener","removeAllGlobalListeners","triggerPressStart","originalEvent","state","current","shouldStopPropagation","event","triggerPressEnd","wasPressed","arguments","length","undefined","triggerPressUp","cancel","e","createEvent","cancelOnPointerExit","pressProps","pressProps2","onKeyDown","_a","isValidKeyboardEvent","nativeEvent","currentTarget","contains","shouldPreventDefaultKeyboard","key","preventDefault","repeat","onKeyUp","stopPropagation","metaKey","metaKeyEvents","set","Map","onClick","button","isOpening","stopPressStart","stopPressUp","stopPressEnd","_b","isHTMLAnchorLink","delete","size","events","values","dispatchEvent","KeyboardEvent","PointerEvent","onPointerDown","shouldPreventDefault","pointerId","onPointerMove","onPointerUp","onPointerCancel","onMouseDown","onDragStart","onMouseUp","onMouseEnter","onMouseLeave","onTouchStart","touch","getTouchFromEvent","identifier","onScroll","onTouchMove","getTouchById","onTouchEnd","onTouchCancel","shiftKey","ctrlKey","altKey","tagName","hasAttribute","code","element","role","getAttribute","HTMLInputElement","isValidInputKey","HTMLTextAreaElement","isContentEditable","targetTouches","changedTouches","i","getPointClientRect","point","offsetX","width","radiusX","offsetY","height","radiusY","top","clientY","right","clientX","bottom","left","areRectanglesOverlapping","a","b","rect","getBoundingClientRect","pointRect","HTMLElement","HTMLButtonElement","type","nonTextInputTypes","Set","has"],"sources":["C:/Users/pk117/Desktop/Personal/pro10150.github.io/node_modules/@nextui-org/use-aria-press/dist/index.mjs"],"sourcesContent":["import {\r\n  PressResponderContext\r\n} from \"./chunk-4XDBEIOV.mjs\";\r\nimport {\r\n  PressEvent\r\n} from \"./chunk-7OGZUKMH.mjs\";\r\nimport {\r\n  disableTextSelection,\r\n  restoreTextSelection\r\n} from \"./chunk-CWMPADA3.mjs\";\r\nimport {\r\n  getOwnerDocument,\r\n  getOwnerWindow\r\n} from \"./chunk-FFBWCXWK.mjs\";\r\nimport \"./chunk-7D66DBGQ.mjs\";\r\n\r\n// src/index.ts\r\nimport {\r\n  focusWithoutScrolling,\r\n  isMac,\r\n  isVirtualClick,\r\n  isVirtualPointerEvent,\r\n  mergeProps,\r\n  openLink,\r\n  useEffectEvent,\r\n  useGlobalListeners,\r\n  useSyncRef\r\n} from \"@react-aria/utils\";\r\nimport { useContext, useEffect, useMemo, useRef, useState } from \"react\";\r\nfunction usePressResponderContext(props) {\r\n  let context = useContext(PressResponderContext);\r\n  if (context) {\r\n    let { register, ...contextProps } = context;\r\n    props = mergeProps(contextProps, props);\r\n    register();\r\n  }\r\n  useSyncRef(context, props.ref);\r\n  return props;\r\n}\r\nvar LINK_CLICKED = Symbol(\"linkClicked\");\r\nfunction usePress(props) {\r\n  let {\r\n    onPress,\r\n    onPressChange,\r\n    onPressStart,\r\n    onPressEnd,\r\n    onPressUp,\r\n    isDisabled,\r\n    isPressed: isPressedProp,\r\n    preventFocusOnPress,\r\n    shouldCancelOnPointerExit,\r\n    allowTextSelectionOnPress,\r\n    ref: _,\r\n    ...domProps\r\n  } = usePressResponderContext(props);\r\n  let [isPressed, setPressed] = useState(false);\r\n  let ref = useRef({\r\n    isPressed: false,\r\n    ignoreEmulatedMouseEvents: false,\r\n    ignoreClickAfterPress: false,\r\n    didFirePressStart: false,\r\n    isTriggeringEvent: false,\r\n    activePointerId: null,\r\n    target: null,\r\n    isOverTarget: false,\r\n    pointerType: null\r\n  });\r\n  let { addGlobalListener, removeAllGlobalListeners } = useGlobalListeners();\r\n  let triggerPressStart = useEffectEvent((originalEvent, pointerType) => {\r\n    let state = ref.current;\r\n    if (isDisabled || state.didFirePressStart) {\r\n      return;\r\n    }\r\n    let shouldStopPropagation = true;\r\n    state.isTriggeringEvent = true;\r\n    if (onPressStart) {\r\n      let event = new PressEvent(\"pressstart\", pointerType, originalEvent);\r\n      onPressStart(event);\r\n      shouldStopPropagation = event.shouldStopPropagation;\r\n    }\r\n    if (onPressChange) {\r\n      onPressChange(true);\r\n    }\r\n    state.isTriggeringEvent = false;\r\n    state.didFirePressStart = true;\r\n    setPressed(true);\r\n    return shouldStopPropagation;\r\n  });\r\n  let triggerPressEnd = useEffectEvent(\r\n    (originalEvent, pointerType, wasPressed = true) => {\r\n      let state = ref.current;\r\n      if (!state.didFirePressStart) {\r\n        return;\r\n      }\r\n      state.ignoreClickAfterPress = true;\r\n      state.didFirePressStart = false;\r\n      state.isTriggeringEvent = true;\r\n      let shouldStopPropagation = true;\r\n      if (onPressEnd) {\r\n        let event = new PressEvent(\"pressend\", pointerType, originalEvent);\r\n        onPressEnd(event);\r\n        shouldStopPropagation = event.shouldStopPropagation;\r\n      }\r\n      if (onPressChange) {\r\n        onPressChange(false);\r\n      }\r\n      setPressed(false);\r\n      if (onPress && wasPressed && !isDisabled) {\r\n        let event = new PressEvent(\"press\", pointerType, originalEvent);\r\n        onPress(event);\r\n        shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\r\n      }\r\n      state.isTriggeringEvent = false;\r\n      return shouldStopPropagation;\r\n    }\r\n  );\r\n  let triggerPressUp = useEffectEvent((originalEvent, pointerType) => {\r\n    let state = ref.current;\r\n    if (isDisabled) {\r\n      return;\r\n    }\r\n    if (onPressUp) {\r\n      state.isTriggeringEvent = true;\r\n      let event = new PressEvent(\"pressup\", pointerType, originalEvent);\r\n      onPressUp(event);\r\n      state.isTriggeringEvent = false;\r\n      return event.shouldStopPropagation;\r\n    }\r\n    return true;\r\n  });\r\n  let cancel = useEffectEvent((e) => {\r\n    let state = ref.current;\r\n    if (state.isPressed) {\r\n      if (state.isOverTarget && state.target) {\r\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\r\n      }\r\n      state.isPressed = false;\r\n      state.isOverTarget = false;\r\n      state.activePointerId = null;\r\n      state.pointerType = null;\r\n      removeAllGlobalListeners();\r\n      if (!allowTextSelectionOnPress && state.target) {\r\n        restoreTextSelection(state.target);\r\n      }\r\n    }\r\n  });\r\n  let cancelOnPointerExit = useEffectEvent((e) => {\r\n    if (shouldCancelOnPointerExit) {\r\n      cancel(e);\r\n    }\r\n  });\r\n  let pressProps = useMemo(() => {\r\n    let state = ref.current;\r\n    let pressProps2 = {\r\n      onKeyDown(e) {\r\n        var _a;\r\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\r\n          if (shouldPreventDefaultKeyboard(e.target, e.key)) {\r\n            e.preventDefault();\r\n          }\r\n          let shouldStopPropagation = true;\r\n          if (!state.isPressed && !e.repeat) {\r\n            state.target = e.currentTarget;\r\n            state.isPressed = true;\r\n            shouldStopPropagation = triggerPressStart(e, \"keyboard\");\r\n            addGlobalListener(getOwnerDocument(e.currentTarget), \"keyup\", onKeyUp, false);\r\n          }\r\n          if (shouldStopPropagation) {\r\n            e.stopPropagation();\r\n          }\r\n          if (e.metaKey && isMac()) {\r\n            (_a = state.metaKeyEvents) == null ? void 0 : _a.set(e.key, e.nativeEvent);\r\n          }\r\n        } else if (e.key === \"Meta\") {\r\n          state.metaKeyEvents = /* @__PURE__ */ new Map();\r\n        }\r\n      },\r\n      onKeyUp(e) {\r\n        if (state.target && isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) {\r\n          triggerPressUp(createEvent(state.target, e), \"keyboard\");\r\n        }\r\n      },\r\n      onClick(e) {\r\n        if (e && !e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        if (e && e.button === 0 && !state.isTriggeringEvent && !openLink.isOpening) {\r\n          let shouldStopPropagation = true;\r\n          if (isDisabled) {\r\n            e.preventDefault();\r\n          }\r\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || isVirtualClick(e.nativeEvent))) {\r\n            if (!isDisabled && !preventFocusOnPress) {\r\n              focusWithoutScrolling(e.currentTarget);\r\n            }\r\n            let stopPressStart = triggerPressStart(e, \"virtual\");\r\n            let stopPressUp = triggerPressUp(e, \"virtual\");\r\n            let stopPressEnd = triggerPressEnd(e, \"virtual\");\r\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\r\n          }\r\n          state.ignoreEmulatedMouseEvents = false;\r\n          state.ignoreClickAfterPress = false;\r\n          if (shouldStopPropagation) {\r\n            e.stopPropagation();\r\n          }\r\n        }\r\n      }\r\n    };\r\n    let onKeyUp = (e) => {\r\n      var _a, _b;\r\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\r\n        if (shouldPreventDefaultKeyboard(e.target, e.key)) {\r\n          e.preventDefault();\r\n        }\r\n        let target = e.target;\r\n        let shouldStopPropagation = triggerPressEnd(\r\n          createEvent(state.target, e),\r\n          \"keyboard\",\r\n          state.target.contains(target)\r\n        );\r\n        removeAllGlobalListeners();\r\n        if (shouldStopPropagation) {\r\n          e.stopPropagation();\r\n        }\r\n        if (e.key !== \"Enter\" && isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[LINK_CLICKED]) {\r\n          e[LINK_CLICKED] = true;\r\n          openLink(state.target, e, false);\r\n        }\r\n        state.isPressed = false;\r\n        (_a = state.metaKeyEvents) == null ? void 0 : _a.delete(e.key);\r\n      } else if (e.key === \"Meta\" && ((_b = state.metaKeyEvents) == null ? void 0 : _b.size)) {\r\n        let events = state.metaKeyEvents;\r\n        state.metaKeyEvents = null;\r\n        for (let event of events.values()) {\r\n          state.target && state.target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\r\n        }\r\n      }\r\n    };\r\n    if (typeof PointerEvent !== \"undefined\") {\r\n      pressProps2.onPointerDown = (e) => {\r\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        if (isVirtualPointerEvent(e.nativeEvent)) {\r\n          state.pointerType = \"virtual\";\r\n          return;\r\n        }\r\n        if (shouldPreventDefault(e.currentTarget)) {\r\n          e.preventDefault();\r\n        }\r\n        state.pointerType = e.pointerType;\r\n        let shouldStopPropagation = true;\r\n        if (!state.isPressed) {\r\n          state.isPressed = true;\r\n          state.isOverTarget = true;\r\n          state.activePointerId = e.pointerId;\r\n          state.target = e.currentTarget;\r\n          if (!isDisabled && !preventFocusOnPress) {\r\n            focusWithoutScrolling(e.currentTarget);\r\n          }\r\n          if (!allowTextSelectionOnPress) {\r\n            disableTextSelection(state.target);\r\n          }\r\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\r\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointermove\", onPointerMove, false);\r\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointerup\", onPointerUp, false);\r\n          addGlobalListener(\r\n            getOwnerDocument(e.currentTarget),\r\n            \"pointercancel\",\r\n            onPointerCancel,\r\n            false\r\n          );\r\n        }\r\n        if (shouldStopPropagation) {\r\n          e.stopPropagation();\r\n        }\r\n      };\r\n      pressProps2.onMouseDown = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        if (e.button === 0) {\r\n          if (shouldPreventDefault(e.currentTarget)) {\r\n            e.preventDefault();\r\n          }\r\n          e.stopPropagation();\r\n        }\r\n      };\r\n      pressProps2.onPointerUp = (e) => {\r\n        if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") {\r\n          return;\r\n        }\r\n        if (e.button === 0 && isOverTarget(e, e.currentTarget)) {\r\n          triggerPressUp(e, state.pointerType || e.pointerType);\r\n        }\r\n      };\r\n      let onPointerMove = (e) => {\r\n        if (e.pointerId !== state.activePointerId || !state.target) {\r\n          return;\r\n        }\r\n        if (isOverTarget(e, state.target)) {\r\n          if (!state.isOverTarget) {\r\n            state.isOverTarget = true;\r\n            triggerPressStart(createEvent(state.target, e), state.pointerType);\r\n          }\r\n        } else if (state.isOverTarget) {\r\n          state.isOverTarget = false;\r\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\r\n          cancelOnPointerExit(e);\r\n        }\r\n      };\r\n      let onPointerUp = (e) => {\r\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\r\n          if (isOverTarget(e, state.target)) {\r\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\r\n          } else if (state.isOverTarget) {\r\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\r\n          }\r\n          state.isPressed = false;\r\n          state.isOverTarget = false;\r\n          state.activePointerId = null;\r\n          state.pointerType = null;\r\n          removeAllGlobalListeners();\r\n          if (!allowTextSelectionOnPress) {\r\n            restoreTextSelection(state.target);\r\n          }\r\n        }\r\n      };\r\n      let onPointerCancel = (e) => {\r\n        cancel(e);\r\n      };\r\n      pressProps2.onDragStart = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        cancel(e);\r\n      };\r\n    } else {\r\n      pressProps2.onMouseDown = (e) => {\r\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        if (shouldPreventDefault(e.currentTarget)) {\r\n          e.preventDefault();\r\n        }\r\n        if (state.ignoreEmulatedMouseEvents) {\r\n          e.stopPropagation();\r\n          return;\r\n        }\r\n        state.isPressed = true;\r\n        state.isOverTarget = true;\r\n        state.target = e.currentTarget;\r\n        state.pointerType = isVirtualClick(e.nativeEvent) ? \"virtual\" : \"mouse\";\r\n        if (!isDisabled && !preventFocusOnPress) {\r\n          focusWithoutScrolling(e.currentTarget);\r\n        }\r\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\r\n        if (shouldStopPropagation) {\r\n          e.stopPropagation();\r\n        }\r\n        addGlobalListener(getOwnerDocument(e.currentTarget), \"mouseup\", onMouseUp, false);\r\n      };\r\n      pressProps2.onMouseEnter = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        let shouldStopPropagation = true;\r\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\r\n          state.isOverTarget = true;\r\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\r\n        }\r\n        if (shouldStopPropagation) {\r\n          e.stopPropagation();\r\n        }\r\n      };\r\n      pressProps2.onMouseLeave = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        let shouldStopPropagation = true;\r\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\r\n          state.isOverTarget = false;\r\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\r\n          cancelOnPointerExit(e);\r\n        }\r\n        if (shouldStopPropagation) {\r\n          e.stopPropagation();\r\n        }\r\n      };\r\n      pressProps2.onMouseUp = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {\r\n          triggerPressUp(e, state.pointerType || \"mouse\");\r\n        }\r\n      };\r\n      let onMouseUp = (e) => {\r\n        if (e.button !== 0) {\r\n          return;\r\n        }\r\n        state.isPressed = false;\r\n        removeAllGlobalListeners();\r\n        if (state.ignoreEmulatedMouseEvents) {\r\n          state.ignoreEmulatedMouseEvents = false;\r\n          return;\r\n        }\r\n        if (!state.target) {\r\n          return;\r\n        }\r\n        if (isOverTarget(e, state.target)) {\r\n          triggerPressEnd(createEvent(state.target, e), state.pointerType);\r\n        } else if (state.isOverTarget) {\r\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\r\n        }\r\n        state.isOverTarget = false;\r\n      };\r\n      pressProps2.onTouchStart = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        let touch = getTouchFromEvent(e.nativeEvent);\r\n        if (!touch) {\r\n          return;\r\n        }\r\n        state.activePointerId = touch.identifier;\r\n        state.ignoreEmulatedMouseEvents = true;\r\n        state.isOverTarget = true;\r\n        state.isPressed = true;\r\n        state.target = e.currentTarget;\r\n        state.pointerType = \"touch\";\r\n        if (!isDisabled && !preventFocusOnPress) {\r\n          focusWithoutScrolling(e.currentTarget);\r\n        }\r\n        if (!allowTextSelectionOnPress) {\r\n          disableTextSelection(state.target);\r\n        }\r\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\r\n        if (shouldStopPropagation) {\r\n          e.stopPropagation();\r\n        }\r\n        addGlobalListener(getOwnerWindow(e.currentTarget), \"scroll\", onScroll, true);\r\n      };\r\n      pressProps2.onTouchMove = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        if (!state.isPressed) {\r\n          e.stopPropagation();\r\n          return;\r\n        }\r\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\r\n        let shouldStopPropagation = true;\r\n        if (touch && isOverTarget(touch, e.currentTarget)) {\r\n          if (!state.isOverTarget) {\r\n            state.isOverTarget = true;\r\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\r\n          }\r\n        } else if (state.isOverTarget) {\r\n          state.isOverTarget = false;\r\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\r\n          cancelOnPointerExit(e);\r\n        }\r\n        if (shouldStopPropagation) {\r\n          e.stopPropagation();\r\n        }\r\n      };\r\n      pressProps2.onTouchEnd = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        if (!state.isPressed) {\r\n          e.stopPropagation();\r\n          return;\r\n        }\r\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\r\n        let shouldStopPropagation = true;\r\n        if (touch && isOverTarget(touch, e.currentTarget)) {\r\n          triggerPressUp(e, state.pointerType);\r\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\r\n        } else if (state.isOverTarget) {\r\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\r\n        }\r\n        if (shouldStopPropagation) {\r\n          e.stopPropagation();\r\n        }\r\n        state.isPressed = false;\r\n        state.activePointerId = null;\r\n        state.isOverTarget = false;\r\n        state.ignoreEmulatedMouseEvents = true;\r\n        if (!allowTextSelectionOnPress && state.target) {\r\n          restoreTextSelection(state.target);\r\n        }\r\n        removeAllGlobalListeners();\r\n      };\r\n      pressProps2.onTouchCancel = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        e.stopPropagation();\r\n        if (state.isPressed) {\r\n          cancel(e);\r\n        }\r\n      };\r\n      let onScroll = (e) => {\r\n        if (state.isPressed && e.target.contains(state.target)) {\r\n          cancel({\r\n            currentTarget: state.target,\r\n            shiftKey: false,\r\n            ctrlKey: false,\r\n            metaKey: false,\r\n            altKey: false\r\n          });\r\n        }\r\n      };\r\n      pressProps2.onDragStart = (e) => {\r\n        if (!e.currentTarget.contains(e.target)) {\r\n          return;\r\n        }\r\n        cancel(e);\r\n      };\r\n    }\r\n    return pressProps2;\r\n  }, [\r\n    addGlobalListener,\r\n    isDisabled,\r\n    preventFocusOnPress,\r\n    removeAllGlobalListeners,\r\n    allowTextSelectionOnPress,\r\n    cancel,\r\n    cancelOnPointerExit,\r\n    triggerPressEnd,\r\n    triggerPressStart,\r\n    triggerPressUp\r\n  ]);\r\n  useEffect(() => {\r\n    return () => {\r\n      if (!allowTextSelectionOnPress && ref.current.target) {\r\n        restoreTextSelection(ref.current.target);\r\n      }\r\n    };\r\n  }, [allowTextSelectionOnPress]);\r\n  return {\r\n    isPressed: isPressedProp || isPressed,\r\n    pressProps: mergeProps(domProps, pressProps)\r\n  };\r\n}\r\nfunction isHTMLAnchorLink(target) {\r\n  return target.tagName === \"A\" && target.hasAttribute(\"href\");\r\n}\r\nfunction isValidKeyboardEvent(event, currentTarget) {\r\n  const { key, code } = event;\r\n  const element = currentTarget;\r\n  const role = element.getAttribute(\"role\");\r\n  return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key) || element instanceof getOwnerWindow(element).HTMLTextAreaElement || element.isContentEditable) && !((role === \"link\" || !role && isHTMLAnchorLink(element)) && key !== \"Enter\");\r\n}\r\nfunction getTouchFromEvent(event) {\r\n  const { targetTouches } = event;\r\n  if (targetTouches.length > 0) {\r\n    return targetTouches[0];\r\n  }\r\n  return null;\r\n}\r\nfunction getTouchById(event, pointerId) {\r\n  const changedTouches = event.changedTouches;\r\n  for (let i = 0; i < changedTouches.length; i++) {\r\n    const touch = changedTouches[i];\r\n    if (touch.identifier === pointerId) {\r\n      return touch;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction createEvent(target, e) {\r\n  return {\r\n    currentTarget: target,\r\n    shiftKey: e.shiftKey,\r\n    ctrlKey: e.ctrlKey,\r\n    metaKey: e.metaKey,\r\n    altKey: e.altKey\r\n  };\r\n}\r\nfunction getPointClientRect(point) {\r\n  let offsetX = !!point.width ? point.width / 2 : point.radiusX || 0;\r\n  let offsetY = !!point.height ? point.height / 2 : point.radiusY || 0;\r\n  return {\r\n    top: point.clientY - offsetY,\r\n    right: point.clientX + offsetX,\r\n    bottom: point.clientY + offsetY,\r\n    left: point.clientX - offsetX\r\n  };\r\n}\r\nfunction areRectanglesOverlapping(a, b) {\r\n  if (a.left > b.right || b.left > a.right) {\r\n    return false;\r\n  }\r\n  if (a.top > b.bottom || b.top > a.bottom) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nfunction isOverTarget(point, target) {\r\n  let rect = target.getBoundingClientRect();\r\n  let pointRect = getPointClientRect(point);\r\n  return areRectanglesOverlapping(rect, pointRect);\r\n}\r\nfunction shouldPreventDefault(target) {\r\n  return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\r\n}\r\nfunction shouldPreventDefaultKeyboard(target, key) {\r\n  if (target instanceof HTMLInputElement) {\r\n    return !isValidInputKey(target, key);\r\n  }\r\n  if (target instanceof HTMLButtonElement) {\r\n    return target.type !== \"submit\" && target.type !== \"reset\";\r\n  }\r\n  if (isHTMLAnchorLink(target)) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nvar nonTextInputTypes = /* @__PURE__ */ new Set([\r\n  \"checkbox\",\r\n  \"radio\",\r\n  \"range\",\r\n  \"color\",\r\n  \"file\",\r\n  \"image\",\r\n  \"button\",\r\n  \"submit\",\r\n  \"reset\"\r\n]);\r\nfunction isValidInputKey(target, key) {\r\n  return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : nonTextInputTypes.has(target.type);\r\n}\r\nexport {\r\n  usePress\r\n};\r\n"],"mappings":";;;AAAA,SACEA,qBAAqB,QAChB,sBAAsB;AAC7B,SACEC,UAAU,QACL,sBAAsB;AAC7B,SACEC,oBAAoB,EACpBC,oBAAoB,QACf,sBAAsB;AAC7B,SACEC,gBAAgB,EAChBC,cAAc,QACT,sBAAsB;AAC7B,OAAO,sBAAsB;;AAE7B;AACA,SACEC,qBAAqB,EACrBC,KAAK,EACLC,cAAc,EACdC,qBAAqB,EACrBC,UAAU,EACVC,QAAQ,EACRC,cAAc,EACdC,kBAAkB,EAClBC,UAAU,QACL,mBAAmB;AAC1B,SAASC,UAAU,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACxE,SAASC,wBAAwBA,CAACC,KAAK,EAAE;EACvC,IAAIC,OAAO,GAAGP,UAAU,CAACf,qBAAqB,CAAC;EAC/C,IAAIsB,OAAO,EAAE;IACX,IAAI;QAAEC;MAA0B,CAAC,GAAGD,OAAO;MAAxBE,YAAY,GAAAC,wBAAA,CAAKH,OAAO,EAAAI,SAAA;IAC3CL,KAAK,GAAGX,UAAU,CAACc,YAAY,EAAEH,KAAK,CAAC;IACvCE,QAAQ,CAAC,CAAC;EACZ;EACAT,UAAU,CAACQ,OAAO,EAAED,KAAK,CAACM,GAAG,CAAC;EAC9B,OAAON,KAAK;AACd;AACA,IAAIO,YAAY,GAAGC,MAAM,CAAC,aAAa,CAAC;AACxC,SAASC,QAAQA,CAACT,KAAK,EAAE;EACvB,IAAAU,qBAAA,GAaIX,wBAAwB,CAACC,KAAK,CAAC;IAb/B;MACFW,OAAO;MACPC,aAAa;MACbC,YAAY;MACZC,UAAU;MACVC,SAAS;MACTC,UAAU;MACVC,SAAS,EAAEC,aAAa;MACxBC,mBAAmB;MACnBC,yBAAyB;MACzBC,yBAAyB;MACzBf,GAAG,EAAEgB;IAEP,CAAC,GAAAZ,qBAAA;IADIa,QAAQ,GAAAnB,wBAAA,CAAAM,qBAAA,EAAAc,UAAA;EAEb,IAAI,CAACP,SAAS,EAAEQ,UAAU,CAAC,GAAG3B,QAAQ,CAAC,KAAK,CAAC;EAC7C,IAAIQ,GAAG,GAAGT,MAAM,CAAC;IACfoB,SAAS,EAAE,KAAK;IAChBS,yBAAyB,EAAE,KAAK;IAChCC,qBAAqB,EAAE,KAAK;IAC5BC,iBAAiB,EAAE,KAAK;IACxBC,iBAAiB,EAAE,KAAK;IACxBC,eAAe,EAAE,IAAI;IACrBC,MAAM,EAAE,IAAI;IACZC,YAAY,EAAE,KAAK;IACnBC,WAAW,EAAE;EACf,CAAC,CAAC;EACF,IAAI;IAAEC,iBAAiB;IAAEC;EAAyB,CAAC,GAAG3C,kBAAkB,CAAC,CAAC;EAC1E,IAAI4C,iBAAiB,GAAG7C,cAAc,CAAC,CAAC8C,aAAa,EAAEJ,WAAW,KAAK;IACrE,IAAIK,KAAK,GAAGhC,GAAG,CAACiC,OAAO;IACvB,IAAIvB,UAAU,IAAIsB,KAAK,CAACV,iBAAiB,EAAE;MACzC;IACF;IACA,IAAIY,qBAAqB,GAAG,IAAI;IAChCF,KAAK,CAACT,iBAAiB,GAAG,IAAI;IAC9B,IAAIhB,YAAY,EAAE;MAChB,IAAI4B,KAAK,GAAG,IAAI7D,UAAU,CAAC,YAAY,EAAEqD,WAAW,EAAEI,aAAa,CAAC;MACpExB,YAAY,CAAC4B,KAAK,CAAC;MACnBD,qBAAqB,GAAGC,KAAK,CAACD,qBAAqB;IACrD;IACA,IAAI5B,aAAa,EAAE;MACjBA,aAAa,CAAC,IAAI,CAAC;IACrB;IACA0B,KAAK,CAACT,iBAAiB,GAAG,KAAK;IAC/BS,KAAK,CAACV,iBAAiB,GAAG,IAAI;IAC9BH,UAAU,CAAC,IAAI,CAAC;IAChB,OAAOe,qBAAqB;EAC9B,CAAC,CAAC;EACF,IAAIE,eAAe,GAAGnD,cAAc,CAClC,UAAC8C,aAAa,EAAEJ,WAAW,EAAwB;IAAA,IAAtBU,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAC5C,IAAIN,KAAK,GAAGhC,GAAG,CAACiC,OAAO;IACvB,IAAI,CAACD,KAAK,CAACV,iBAAiB,EAAE;MAC5B;IACF;IACAU,KAAK,CAACX,qBAAqB,GAAG,IAAI;IAClCW,KAAK,CAACV,iBAAiB,GAAG,KAAK;IAC/BU,KAAK,CAACT,iBAAiB,GAAG,IAAI;IAC9B,IAAIW,qBAAqB,GAAG,IAAI;IAChC,IAAI1B,UAAU,EAAE;MACd,IAAI2B,KAAK,GAAG,IAAI7D,UAAU,CAAC,UAAU,EAAEqD,WAAW,EAAEI,aAAa,CAAC;MAClEvB,UAAU,CAAC2B,KAAK,CAAC;MACjBD,qBAAqB,GAAGC,KAAK,CAACD,qBAAqB;IACrD;IACA,IAAI5B,aAAa,EAAE;MACjBA,aAAa,CAAC,KAAK,CAAC;IACtB;IACAa,UAAU,CAAC,KAAK,CAAC;IACjB,IAAId,OAAO,IAAIgC,UAAU,IAAI,CAAC3B,UAAU,EAAE;MACxC,IAAIyB,KAAK,GAAG,IAAI7D,UAAU,CAAC,OAAO,EAAEqD,WAAW,EAAEI,aAAa,CAAC;MAC/D1B,OAAO,CAAC8B,KAAK,CAAC;MACdD,qBAAqB,KAAKA,qBAAqB,GAAGC,KAAK,CAACD,qBAAqB,CAAC;IAChF;IACAF,KAAK,CAACT,iBAAiB,GAAG,KAAK;IAC/B,OAAOW,qBAAqB;EAC9B,CACF,CAAC;EACD,IAAIO,cAAc,GAAGxD,cAAc,CAAC,CAAC8C,aAAa,EAAEJ,WAAW,KAAK;IAClE,IAAIK,KAAK,GAAGhC,GAAG,CAACiC,OAAO;IACvB,IAAIvB,UAAU,EAAE;MACd;IACF;IACA,IAAID,SAAS,EAAE;MACbuB,KAAK,CAACT,iBAAiB,GAAG,IAAI;MAC9B,IAAIY,KAAK,GAAG,IAAI7D,UAAU,CAAC,SAAS,EAAEqD,WAAW,EAAEI,aAAa,CAAC;MACjEtB,SAAS,CAAC0B,KAAK,CAAC;MAChBH,KAAK,CAACT,iBAAiB,GAAG,KAAK;MAC/B,OAAOY,KAAK,CAACD,qBAAqB;IACpC;IACA,OAAO,IAAI;EACb,CAAC,CAAC;EACF,IAAIQ,MAAM,GAAGzD,cAAc,CAAE0D,CAAC,IAAK;IACjC,IAAIX,KAAK,GAAGhC,GAAG,CAACiC,OAAO;IACvB,IAAID,KAAK,CAACrB,SAAS,EAAE;MACnB,IAAIqB,KAAK,CAACN,YAAY,IAAIM,KAAK,CAACP,MAAM,EAAE;QACtCW,eAAe,CAACQ,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAAEX,KAAK,CAACL,WAAW,EAAE,KAAK,CAAC;MACzE;MACAK,KAAK,CAACrB,SAAS,GAAG,KAAK;MACvBqB,KAAK,CAACN,YAAY,GAAG,KAAK;MAC1BM,KAAK,CAACR,eAAe,GAAG,IAAI;MAC5BQ,KAAK,CAACL,WAAW,GAAG,IAAI;MACxBE,wBAAwB,CAAC,CAAC;MAC1B,IAAI,CAACd,yBAAyB,IAAIiB,KAAK,CAACP,MAAM,EAAE;QAC9CjD,oBAAoB,CAACwD,KAAK,CAACP,MAAM,CAAC;MACpC;IACF;EACF,CAAC,CAAC;EACF,IAAIoB,mBAAmB,GAAG5D,cAAc,CAAE0D,CAAC,IAAK;IAC9C,IAAI7B,yBAAyB,EAAE;MAC7B4B,MAAM,CAACC,CAAC,CAAC;IACX;EACF,CAAC,CAAC;EACF,IAAIG,UAAU,GAAGxD,OAAO,CAAC,MAAM;IAC7B,IAAI0C,KAAK,GAAGhC,GAAG,CAACiC,OAAO;IACvB,IAAIc,WAAW,GAAG;MAChBC,SAASA,CAACL,CAAC,EAAE;QACX,IAAIM,EAAE;QACN,IAAIC,oBAAoB,CAACP,CAAC,CAACQ,WAAW,EAAER,CAAC,CAACS,aAAa,CAAC,IAAIT,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UAC9F,IAAI6B,4BAA4B,CAACX,CAAC,CAAClB,MAAM,EAAEkB,CAAC,CAACY,GAAG,CAAC,EAAE;YACjDZ,CAAC,CAACa,cAAc,CAAC,CAAC;UACpB;UACA,IAAItB,qBAAqB,GAAG,IAAI;UAChC,IAAI,CAACF,KAAK,CAACrB,SAAS,IAAI,CAACgC,CAAC,CAACc,MAAM,EAAE;YACjCzB,KAAK,CAACP,MAAM,GAAGkB,CAAC,CAACS,aAAa;YAC9BpB,KAAK,CAACrB,SAAS,GAAG,IAAI;YACtBuB,qBAAqB,GAAGJ,iBAAiB,CAACa,CAAC,EAAE,UAAU,CAAC;YACxDf,iBAAiB,CAACnD,gBAAgB,CAACkE,CAAC,CAACS,aAAa,CAAC,EAAE,OAAO,EAAEM,OAAO,EAAE,KAAK,CAAC;UAC/E;UACA,IAAIxB,qBAAqB,EAAE;YACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;UACrB;UACA,IAAIhB,CAAC,CAACiB,OAAO,IAAIhF,KAAK,CAAC,CAAC,EAAE;YACxB,CAACqE,EAAE,GAAGjB,KAAK,CAAC6B,aAAa,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGZ,EAAE,CAACa,GAAG,CAACnB,CAAC,CAACY,GAAG,EAAEZ,CAAC,CAACQ,WAAW,CAAC;UAC5E;QACF,CAAC,MAAM,IAAIR,CAAC,CAACY,GAAG,KAAK,MAAM,EAAE;UAC3BvB,KAAK,CAAC6B,aAAa,GAAG,eAAgB,IAAIE,GAAG,CAAC,CAAC;QACjD;MACF,CAAC;MACDL,OAAOA,CAACf,CAAC,EAAE;QACT,IAAIX,KAAK,CAACP,MAAM,IAAIyB,oBAAoB,CAACP,CAAC,CAACQ,WAAW,EAAER,CAAC,CAACS,aAAa,CAAC,IAAI,CAACT,CAAC,CAACc,MAAM,IAAId,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UAC3HgB,cAAc,CAACG,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAAE,UAAU,CAAC;QAC1D;MACF,CAAC;MACDqB,OAAOA,CAACrB,CAAC,EAAE;QACT,IAAIA,CAAC,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UAC5C;QACF;QACA,IAAIkB,CAAC,IAAIA,CAAC,CAACsB,MAAM,KAAK,CAAC,IAAI,CAACjC,KAAK,CAACT,iBAAiB,IAAI,CAACvC,QAAQ,CAACkF,SAAS,EAAE;UAC1E,IAAIhC,qBAAqB,GAAG,IAAI;UAChC,IAAIxB,UAAU,EAAE;YACdiC,CAAC,CAACa,cAAc,CAAC,CAAC;UACpB;UACA,IAAI,CAACxB,KAAK,CAACX,qBAAqB,IAAI,CAACW,KAAK,CAACZ,yBAAyB,IAAI,CAACY,KAAK,CAACrB,SAAS,KAAKqB,KAAK,CAACL,WAAW,KAAK,SAAS,IAAI9C,cAAc,CAAC8D,CAAC,CAACQ,WAAW,CAAC,CAAC,EAAE;YAC9J,IAAI,CAACzC,UAAU,IAAI,CAACG,mBAAmB,EAAE;cACvClC,qBAAqB,CAACgE,CAAC,CAACS,aAAa,CAAC;YACxC;YACA,IAAIe,cAAc,GAAGrC,iBAAiB,CAACa,CAAC,EAAE,SAAS,CAAC;YACpD,IAAIyB,WAAW,GAAG3B,cAAc,CAACE,CAAC,EAAE,SAAS,CAAC;YAC9C,IAAI0B,YAAY,GAAGjC,eAAe,CAACO,CAAC,EAAE,SAAS,CAAC;YAChDT,qBAAqB,GAAGiC,cAAc,IAAIC,WAAW,IAAIC,YAAY;UACvE;UACArC,KAAK,CAACZ,yBAAyB,GAAG,KAAK;UACvCY,KAAK,CAACX,qBAAqB,GAAG,KAAK;UACnC,IAAIa,qBAAqB,EAAE;YACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;UACrB;QACF;MACF;IACF,CAAC;IACD,IAAID,OAAO,GAAIf,CAAC,IAAK;MACnB,IAAIM,EAAE,EAAEqB,EAAE;MACV,IAAItC,KAAK,CAACrB,SAAS,IAAIqB,KAAK,CAACP,MAAM,IAAIyB,oBAAoB,CAACP,CAAC,EAAEX,KAAK,CAACP,MAAM,CAAC,EAAE;QAC5E,IAAI6B,4BAA4B,CAACX,CAAC,CAAClB,MAAM,EAAEkB,CAAC,CAACY,GAAG,CAAC,EAAE;UACjDZ,CAAC,CAACa,cAAc,CAAC,CAAC;QACpB;QACA,IAAI/B,MAAM,GAAGkB,CAAC,CAAClB,MAAM;QACrB,IAAIS,qBAAqB,GAAGE,eAAe,CACzCQ,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAC5B,UAAU,EACVX,KAAK,CAACP,MAAM,CAAC4B,QAAQ,CAAC5B,MAAM,CAC9B,CAAC;QACDI,wBAAwB,CAAC,CAAC;QAC1B,IAAIK,qBAAqB,EAAE;UACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;QACA,IAAIhB,CAAC,CAACY,GAAG,KAAK,OAAO,IAAIgB,gBAAgB,CAACvC,KAAK,CAACP,MAAM,CAAC,IAAIO,KAAK,CAACP,MAAM,CAAC4B,QAAQ,CAAC5B,MAAM,CAAC,IAAI,CAACkB,CAAC,CAAC1C,YAAY,CAAC,EAAE;UAC5G0C,CAAC,CAAC1C,YAAY,CAAC,GAAG,IAAI;UACtBjB,QAAQ,CAACgD,KAAK,CAACP,MAAM,EAAEkB,CAAC,EAAE,KAAK,CAAC;QAClC;QACAX,KAAK,CAACrB,SAAS,GAAG,KAAK;QACvB,CAACsC,EAAE,GAAGjB,KAAK,CAAC6B,aAAa,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGZ,EAAE,CAACuB,MAAM,CAAC7B,CAAC,CAACY,GAAG,CAAC;MAChE,CAAC,MAAM,IAAIZ,CAAC,CAACY,GAAG,KAAK,MAAM,KAAK,CAACe,EAAE,GAAGtC,KAAK,CAAC6B,aAAa,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGS,EAAE,CAACG,IAAI,CAAC,EAAE;QACtF,IAAIC,MAAM,GAAG1C,KAAK,CAAC6B,aAAa;QAChC7B,KAAK,CAAC6B,aAAa,GAAG,IAAI;QAC1B,KAAK,IAAI1B,KAAK,IAAIuC,MAAM,CAACC,MAAM,CAAC,CAAC,EAAE;UACjC3C,KAAK,CAACP,MAAM,IAAIO,KAAK,CAACP,MAAM,CAACmD,aAAa,CAAC,IAAIC,aAAa,CAAC,OAAO,EAAE1C,KAAK,CAAC,CAAC;QAC/E;MACF;IACF,CAAC;IACD,IAAI,OAAO2C,YAAY,KAAK,WAAW,EAAE;MACvC/B,WAAW,CAACgC,aAAa,GAAIpC,CAAC,IAAK;QACjC,IAAIA,CAAC,CAACsB,MAAM,KAAK,CAAC,IAAI,CAACtB,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACzD;QACF;QACA,IAAI3C,qBAAqB,CAAC6D,CAAC,CAACQ,WAAW,CAAC,EAAE;UACxCnB,KAAK,CAACL,WAAW,GAAG,SAAS;UAC7B;QACF;QACA,IAAIqD,oBAAoB,CAACrC,CAAC,CAACS,aAAa,CAAC,EAAE;UACzCT,CAAC,CAACa,cAAc,CAAC,CAAC;QACpB;QACAxB,KAAK,CAACL,WAAW,GAAGgB,CAAC,CAAChB,WAAW;QACjC,IAAIO,qBAAqB,GAAG,IAAI;QAChC,IAAI,CAACF,KAAK,CAACrB,SAAS,EAAE;UACpBqB,KAAK,CAACrB,SAAS,GAAG,IAAI;UACtBqB,KAAK,CAACN,YAAY,GAAG,IAAI;UACzBM,KAAK,CAACR,eAAe,GAAGmB,CAAC,CAACsC,SAAS;UACnCjD,KAAK,CAACP,MAAM,GAAGkB,CAAC,CAACS,aAAa;UAC9B,IAAI,CAAC1C,UAAU,IAAI,CAACG,mBAAmB,EAAE;YACvClC,qBAAqB,CAACgE,CAAC,CAACS,aAAa,CAAC;UACxC;UACA,IAAI,CAACrC,yBAAyB,EAAE;YAC9BxC,oBAAoB,CAACyD,KAAK,CAACP,MAAM,CAAC;UACpC;UACAS,qBAAqB,GAAGJ,iBAAiB,CAACa,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;UAC/DC,iBAAiB,CAACnD,gBAAgB,CAACkE,CAAC,CAACS,aAAa,CAAC,EAAE,aAAa,EAAE8B,aAAa,EAAE,KAAK,CAAC;UACzFtD,iBAAiB,CAACnD,gBAAgB,CAACkE,CAAC,CAACS,aAAa,CAAC,EAAE,WAAW,EAAE+B,WAAW,EAAE,KAAK,CAAC;UACrFvD,iBAAiB,CACfnD,gBAAgB,CAACkE,CAAC,CAACS,aAAa,CAAC,EACjC,eAAe,EACfgC,eAAe,EACf,KACF,CAAC;QACH;QACA,IAAIlD,qBAAqB,EAAE;UACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;MACF,CAAC;MACDZ,WAAW,CAACsC,WAAW,GAAI1C,CAAC,IAAK;QAC/B,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACA,IAAIkB,CAAC,CAACsB,MAAM,KAAK,CAAC,EAAE;UAClB,IAAIe,oBAAoB,CAACrC,CAAC,CAACS,aAAa,CAAC,EAAE;YACzCT,CAAC,CAACa,cAAc,CAAC,CAAC;UACpB;UACAb,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;MACF,CAAC;MACDZ,WAAW,CAACoC,WAAW,GAAIxC,CAAC,IAAK;QAC/B,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,IAAIO,KAAK,CAACL,WAAW,KAAK,SAAS,EAAE;UAC1E;QACF;QACA,IAAIgB,CAAC,CAACsB,MAAM,KAAK,CAAC,IAAIvC,YAAY,CAACiB,CAAC,EAAEA,CAAC,CAACS,aAAa,CAAC,EAAE;UACtDX,cAAc,CAACE,CAAC,EAAEX,KAAK,CAACL,WAAW,IAAIgB,CAAC,CAAChB,WAAW,CAAC;QACvD;MACF,CAAC;MACD,IAAIuD,aAAa,GAAIvC,CAAC,IAAK;QACzB,IAAIA,CAAC,CAACsC,SAAS,KAAKjD,KAAK,CAACR,eAAe,IAAI,CAACQ,KAAK,CAACP,MAAM,EAAE;UAC1D;QACF;QACA,IAAIC,YAAY,CAACiB,CAAC,EAAEX,KAAK,CAACP,MAAM,CAAC,EAAE;UACjC,IAAI,CAACO,KAAK,CAACN,YAAY,EAAE;YACvBM,KAAK,CAACN,YAAY,GAAG,IAAI;YACzBI,iBAAiB,CAACc,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;UACpE;QACF,CAAC,MAAM,IAAIK,KAAK,CAACN,YAAY,EAAE;UAC7BM,KAAK,CAACN,YAAY,GAAG,KAAK;UAC1BU,eAAe,CAACQ,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAAEX,KAAK,CAACL,WAAW,EAAE,KAAK,CAAC;UACvEkB,mBAAmB,CAACF,CAAC,CAAC;QACxB;MACF,CAAC;MACD,IAAIwC,WAAW,GAAIxC,CAAC,IAAK;QACvB,IAAIA,CAAC,CAACsC,SAAS,KAAKjD,KAAK,CAACR,eAAe,IAAIQ,KAAK,CAACrB,SAAS,IAAIgC,CAAC,CAACsB,MAAM,KAAK,CAAC,IAAIjC,KAAK,CAACP,MAAM,EAAE;UAC9F,IAAIC,YAAY,CAACiB,CAAC,EAAEX,KAAK,CAACP,MAAM,CAAC,EAAE;YACjCW,eAAe,CAACQ,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;UAClE,CAAC,MAAM,IAAIK,KAAK,CAACN,YAAY,EAAE;YAC7BU,eAAe,CAACQ,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;UAClE;UACAK,KAAK,CAACrB,SAAS,GAAG,KAAK;UACvBqB,KAAK,CAACN,YAAY,GAAG,KAAK;UAC1BM,KAAK,CAACR,eAAe,GAAG,IAAI;UAC5BQ,KAAK,CAACL,WAAW,GAAG,IAAI;UACxBE,wBAAwB,CAAC,CAAC;UAC1B,IAAI,CAACd,yBAAyB,EAAE;YAC9BvC,oBAAoB,CAACwD,KAAK,CAACP,MAAM,CAAC;UACpC;QACF;MACF,CAAC;MACD,IAAI2D,eAAe,GAAIzC,CAAC,IAAK;QAC3BD,MAAM,CAACC,CAAC,CAAC;MACX,CAAC;MACDI,WAAW,CAACuC,WAAW,GAAI3C,CAAC,IAAK;QAC/B,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACAiB,MAAM,CAACC,CAAC,CAAC;MACX,CAAC;IACH,CAAC,MAAM;MACLI,WAAW,CAACsC,WAAW,GAAI1C,CAAC,IAAK;QAC/B,IAAIA,CAAC,CAACsB,MAAM,KAAK,CAAC,IAAI,CAACtB,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACzD;QACF;QACA,IAAIuD,oBAAoB,CAACrC,CAAC,CAACS,aAAa,CAAC,EAAE;UACzCT,CAAC,CAACa,cAAc,CAAC,CAAC;QACpB;QACA,IAAIxB,KAAK,CAACZ,yBAAyB,EAAE;UACnCuB,CAAC,CAACgB,eAAe,CAAC,CAAC;UACnB;QACF;QACA3B,KAAK,CAACrB,SAAS,GAAG,IAAI;QACtBqB,KAAK,CAACN,YAAY,GAAG,IAAI;QACzBM,KAAK,CAACP,MAAM,GAAGkB,CAAC,CAACS,aAAa;QAC9BpB,KAAK,CAACL,WAAW,GAAG9C,cAAc,CAAC8D,CAAC,CAACQ,WAAW,CAAC,GAAG,SAAS,GAAG,OAAO;QACvE,IAAI,CAACzC,UAAU,IAAI,CAACG,mBAAmB,EAAE;UACvClC,qBAAqB,CAACgE,CAAC,CAACS,aAAa,CAAC;QACxC;QACA,IAAIlB,qBAAqB,GAAGJ,iBAAiB,CAACa,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;QACnE,IAAIO,qBAAqB,EAAE;UACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;QACA/B,iBAAiB,CAACnD,gBAAgB,CAACkE,CAAC,CAACS,aAAa,CAAC,EAAE,SAAS,EAAEmC,SAAS,EAAE,KAAK,CAAC;MACnF,CAAC;MACDxC,WAAW,CAACyC,YAAY,GAAI7C,CAAC,IAAK;QAChC,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACA,IAAIS,qBAAqB,GAAG,IAAI;QAChC,IAAIF,KAAK,CAACrB,SAAS,IAAI,CAACqB,KAAK,CAACZ,yBAAyB,EAAE;UACvDY,KAAK,CAACN,YAAY,GAAG,IAAI;UACzBQ,qBAAqB,GAAGJ,iBAAiB,CAACa,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;QACjE;QACA,IAAIO,qBAAqB,EAAE;UACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;MACF,CAAC;MACDZ,WAAW,CAAC0C,YAAY,GAAI9C,CAAC,IAAK;QAChC,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACA,IAAIS,qBAAqB,GAAG,IAAI;QAChC,IAAIF,KAAK,CAACrB,SAAS,IAAI,CAACqB,KAAK,CAACZ,yBAAyB,EAAE;UACvDY,KAAK,CAACN,YAAY,GAAG,KAAK;UAC1BQ,qBAAqB,GAAGE,eAAe,CAACO,CAAC,EAAEX,KAAK,CAACL,WAAW,EAAE,KAAK,CAAC;UACpEkB,mBAAmB,CAACF,CAAC,CAAC;QACxB;QACA,IAAIT,qBAAqB,EAAE;UACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;MACF,CAAC;MACDZ,WAAW,CAACwC,SAAS,GAAI5C,CAAC,IAAK;QAC7B,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACA,IAAI,CAACO,KAAK,CAACZ,yBAAyB,IAAIuB,CAAC,CAACsB,MAAM,KAAK,CAAC,EAAE;UACtDxB,cAAc,CAACE,CAAC,EAAEX,KAAK,CAACL,WAAW,IAAI,OAAO,CAAC;QACjD;MACF,CAAC;MACD,IAAI4D,SAAS,GAAI5C,CAAC,IAAK;QACrB,IAAIA,CAAC,CAACsB,MAAM,KAAK,CAAC,EAAE;UAClB;QACF;QACAjC,KAAK,CAACrB,SAAS,GAAG,KAAK;QACvBkB,wBAAwB,CAAC,CAAC;QAC1B,IAAIG,KAAK,CAACZ,yBAAyB,EAAE;UACnCY,KAAK,CAACZ,yBAAyB,GAAG,KAAK;UACvC;QACF;QACA,IAAI,CAACY,KAAK,CAACP,MAAM,EAAE;UACjB;QACF;QACA,IAAIC,YAAY,CAACiB,CAAC,EAAEX,KAAK,CAACP,MAAM,CAAC,EAAE;UACjCW,eAAe,CAACQ,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;QAClE,CAAC,MAAM,IAAIK,KAAK,CAACN,YAAY,EAAE;UAC7BU,eAAe,CAACQ,WAAW,CAACZ,KAAK,CAACP,MAAM,EAAEkB,CAAC,CAAC,EAAEX,KAAK,CAACL,WAAW,EAAE,KAAK,CAAC;QACzE;QACAK,KAAK,CAACN,YAAY,GAAG,KAAK;MAC5B,CAAC;MACDqB,WAAW,CAAC2C,YAAY,GAAI/C,CAAC,IAAK;QAChC,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACA,IAAIkE,KAAK,GAAGC,iBAAiB,CAACjD,CAAC,CAACQ,WAAW,CAAC;QAC5C,IAAI,CAACwC,KAAK,EAAE;UACV;QACF;QACA3D,KAAK,CAACR,eAAe,GAAGmE,KAAK,CAACE,UAAU;QACxC7D,KAAK,CAACZ,yBAAyB,GAAG,IAAI;QACtCY,KAAK,CAACN,YAAY,GAAG,IAAI;QACzBM,KAAK,CAACrB,SAAS,GAAG,IAAI;QACtBqB,KAAK,CAACP,MAAM,GAAGkB,CAAC,CAACS,aAAa;QAC9BpB,KAAK,CAACL,WAAW,GAAG,OAAO;QAC3B,IAAI,CAACjB,UAAU,IAAI,CAACG,mBAAmB,EAAE;UACvClC,qBAAqB,CAACgE,CAAC,CAACS,aAAa,CAAC;QACxC;QACA,IAAI,CAACrC,yBAAyB,EAAE;UAC9BxC,oBAAoB,CAACyD,KAAK,CAACP,MAAM,CAAC;QACpC;QACA,IAAIS,qBAAqB,GAAGJ,iBAAiB,CAACa,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;QACnE,IAAIO,qBAAqB,EAAE;UACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;QACA/B,iBAAiB,CAAClD,cAAc,CAACiE,CAAC,CAACS,aAAa,CAAC,EAAE,QAAQ,EAAE0C,QAAQ,EAAE,IAAI,CAAC;MAC9E,CAAC;MACD/C,WAAW,CAACgD,WAAW,GAAIpD,CAAC,IAAK;QAC/B,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACA,IAAI,CAACO,KAAK,CAACrB,SAAS,EAAE;UACpBgC,CAAC,CAACgB,eAAe,CAAC,CAAC;UACnB;QACF;QACA,IAAIgC,KAAK,GAAGK,YAAY,CAACrD,CAAC,CAACQ,WAAW,EAAEnB,KAAK,CAACR,eAAe,CAAC;QAC9D,IAAIU,qBAAqB,GAAG,IAAI;QAChC,IAAIyD,KAAK,IAAIjE,YAAY,CAACiE,KAAK,EAAEhD,CAAC,CAACS,aAAa,CAAC,EAAE;UACjD,IAAI,CAACpB,KAAK,CAACN,YAAY,EAAE;YACvBM,KAAK,CAACN,YAAY,GAAG,IAAI;YACzBQ,qBAAqB,GAAGJ,iBAAiB,CAACa,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;UACjE;QACF,CAAC,MAAM,IAAIK,KAAK,CAACN,YAAY,EAAE;UAC7BM,KAAK,CAACN,YAAY,GAAG,KAAK;UAC1BQ,qBAAqB,GAAGE,eAAe,CAACO,CAAC,EAAEX,KAAK,CAACL,WAAW,EAAE,KAAK,CAAC;UACpEkB,mBAAmB,CAACF,CAAC,CAAC;QACxB;QACA,IAAIT,qBAAqB,EAAE;UACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;MACF,CAAC;MACDZ,WAAW,CAACkD,UAAU,GAAItD,CAAC,IAAK;QAC9B,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACA,IAAI,CAACO,KAAK,CAACrB,SAAS,EAAE;UACpBgC,CAAC,CAACgB,eAAe,CAAC,CAAC;UACnB;QACF;QACA,IAAIgC,KAAK,GAAGK,YAAY,CAACrD,CAAC,CAACQ,WAAW,EAAEnB,KAAK,CAACR,eAAe,CAAC;QAC9D,IAAIU,qBAAqB,GAAG,IAAI;QAChC,IAAIyD,KAAK,IAAIjE,YAAY,CAACiE,KAAK,EAAEhD,CAAC,CAACS,aAAa,CAAC,EAAE;UACjDX,cAAc,CAACE,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;UACpCO,qBAAqB,GAAGE,eAAe,CAACO,CAAC,EAAEX,KAAK,CAACL,WAAW,CAAC;QAC/D,CAAC,MAAM,IAAIK,KAAK,CAACN,YAAY,EAAE;UAC7BQ,qBAAqB,GAAGE,eAAe,CAACO,CAAC,EAAEX,KAAK,CAACL,WAAW,EAAE,KAAK,CAAC;QACtE;QACA,IAAIO,qBAAqB,EAAE;UACzBS,CAAC,CAACgB,eAAe,CAAC,CAAC;QACrB;QACA3B,KAAK,CAACrB,SAAS,GAAG,KAAK;QACvBqB,KAAK,CAACR,eAAe,GAAG,IAAI;QAC5BQ,KAAK,CAACN,YAAY,GAAG,KAAK;QAC1BM,KAAK,CAACZ,yBAAyB,GAAG,IAAI;QACtC,IAAI,CAACL,yBAAyB,IAAIiB,KAAK,CAACP,MAAM,EAAE;UAC9CjD,oBAAoB,CAACwD,KAAK,CAACP,MAAM,CAAC;QACpC;QACAI,wBAAwB,CAAC,CAAC;MAC5B,CAAC;MACDkB,WAAW,CAACmD,aAAa,GAAIvD,CAAC,IAAK;QACjC,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACAkB,CAAC,CAACgB,eAAe,CAAC,CAAC;QACnB,IAAI3B,KAAK,CAACrB,SAAS,EAAE;UACnB+B,MAAM,CAACC,CAAC,CAAC;QACX;MACF,CAAC;MACD,IAAImD,QAAQ,GAAInD,CAAC,IAAK;QACpB,IAAIX,KAAK,CAACrB,SAAS,IAAIgC,CAAC,CAAClB,MAAM,CAAC4B,QAAQ,CAACrB,KAAK,CAACP,MAAM,CAAC,EAAE;UACtDiB,MAAM,CAAC;YACLU,aAAa,EAAEpB,KAAK,CAACP,MAAM;YAC3B0E,QAAQ,EAAE,KAAK;YACfC,OAAO,EAAE,KAAK;YACdxC,OAAO,EAAE,KAAK;YACdyC,MAAM,EAAE;UACV,CAAC,CAAC;QACJ;MACF,CAAC;MACDtD,WAAW,CAACuC,WAAW,GAAI3C,CAAC,IAAK;QAC/B,IAAI,CAACA,CAAC,CAACS,aAAa,CAACC,QAAQ,CAACV,CAAC,CAAClB,MAAM,CAAC,EAAE;UACvC;QACF;QACAiB,MAAM,CAACC,CAAC,CAAC;MACX,CAAC;IACH;IACA,OAAOI,WAAW;EACpB,CAAC,EAAE,CACDnB,iBAAiB,EACjBlB,UAAU,EACVG,mBAAmB,EACnBgB,wBAAwB,EACxBd,yBAAyB,EACzB2B,MAAM,EACNG,mBAAmB,EACnBT,eAAe,EACfN,iBAAiB,EACjBW,cAAc,CACf,CAAC;EACFpD,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACX,IAAI,CAAC0B,yBAAyB,IAAIf,GAAG,CAACiC,OAAO,CAACR,MAAM,EAAE;QACpDjD,oBAAoB,CAACwB,GAAG,CAACiC,OAAO,CAACR,MAAM,CAAC;MAC1C;IACF,CAAC;EACH,CAAC,EAAE,CAACV,yBAAyB,CAAC,CAAC;EAC/B,OAAO;IACLJ,SAAS,EAAEC,aAAa,IAAID,SAAS;IACrCmC,UAAU,EAAE/D,UAAU,CAACkC,QAAQ,EAAE6B,UAAU;EAC7C,CAAC;AACH;AACA,SAASyB,gBAAgBA,CAAC9C,MAAM,EAAE;EAChC,OAAOA,MAAM,CAAC6E,OAAO,KAAK,GAAG,IAAI7E,MAAM,CAAC8E,YAAY,CAAC,MAAM,CAAC;AAC9D;AACA,SAASrD,oBAAoBA,CAACf,KAAK,EAAEiB,aAAa,EAAE;EAClD,MAAM;IAAEG,GAAG;IAAEiD;EAAK,CAAC,GAAGrE,KAAK;EAC3B,MAAMsE,OAAO,GAAGrD,aAAa;EAC7B,MAAMsD,IAAI,GAAGD,OAAO,CAACE,YAAY,CAAC,MAAM,CAAC;EACzC,OAAO,CAACpD,GAAG,KAAK,OAAO,IAAIA,GAAG,KAAK,GAAG,IAAIA,GAAG,KAAK,UAAU,IAAIiD,IAAI,KAAK,OAAO,KAAK,EAAEC,OAAO,YAAY/H,cAAc,CAAC+H,OAAO,CAAC,CAACG,gBAAgB,IAAI,CAACC,eAAe,CAACJ,OAAO,EAAElD,GAAG,CAAC,IAAIkD,OAAO,YAAY/H,cAAc,CAAC+H,OAAO,CAAC,CAACK,mBAAmB,IAAIL,OAAO,CAACM,iBAAiB,CAAC,IAAI,EAAE,CAACL,IAAI,KAAK,MAAM,IAAI,CAACA,IAAI,IAAInC,gBAAgB,CAACkC,OAAO,CAAC,KAAKlD,GAAG,KAAK,OAAO,CAAC;AACvW;AACA,SAASqC,iBAAiBA,CAACzD,KAAK,EAAE;EAChC,MAAM;IAAE6E;EAAc,CAAC,GAAG7E,KAAK;EAC/B,IAAI6E,aAAa,CAACzE,MAAM,GAAG,CAAC,EAAE;IAC5B,OAAOyE,aAAa,CAAC,CAAC,CAAC;EACzB;EACA,OAAO,IAAI;AACb;AACA,SAAShB,YAAYA,CAAC7D,KAAK,EAAE8C,SAAS,EAAE;EACtC,MAAMgC,cAAc,GAAG9E,KAAK,CAAC8E,cAAc;EAC3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,cAAc,CAAC1E,MAAM,EAAE2E,CAAC,EAAE,EAAE;IAC9C,MAAMvB,KAAK,GAAGsB,cAAc,CAACC,CAAC,CAAC;IAC/B,IAAIvB,KAAK,CAACE,UAAU,KAAKZ,SAAS,EAAE;MAClC,OAAOU,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AACA,SAAS/C,WAAWA,CAACnB,MAAM,EAAEkB,CAAC,EAAE;EAC9B,OAAO;IACLS,aAAa,EAAE3B,MAAM;IACrB0E,QAAQ,EAAExD,CAAC,CAACwD,QAAQ;IACpBC,OAAO,EAAEzD,CAAC,CAACyD,OAAO;IAClBxC,OAAO,EAAEjB,CAAC,CAACiB,OAAO;IAClByC,MAAM,EAAE1D,CAAC,CAAC0D;EACZ,CAAC;AACH;AACA,SAASc,kBAAkBA,CAACC,KAAK,EAAE;EACjC,IAAIC,OAAO,GAAG,CAAC,CAACD,KAAK,CAACE,KAAK,GAAGF,KAAK,CAACE,KAAK,GAAG,CAAC,GAAGF,KAAK,CAACG,OAAO,IAAI,CAAC;EAClE,IAAIC,OAAO,GAAG,CAAC,CAACJ,KAAK,CAACK,MAAM,GAAGL,KAAK,CAACK,MAAM,GAAG,CAAC,GAAGL,KAAK,CAACM,OAAO,IAAI,CAAC;EACpE,OAAO;IACLC,GAAG,EAAEP,KAAK,CAACQ,OAAO,GAAGJ,OAAO;IAC5BK,KAAK,EAAET,KAAK,CAACU,OAAO,GAAGT,OAAO;IAC9BU,MAAM,EAAEX,KAAK,CAACQ,OAAO,GAAGJ,OAAO;IAC/BQ,IAAI,EAAEZ,KAAK,CAACU,OAAO,GAAGT;EACxB,CAAC;AACH;AACA,SAASY,wBAAwBA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACtC,IAAID,CAAC,CAACF,IAAI,GAAGG,CAAC,CAACN,KAAK,IAAIM,CAAC,CAACH,IAAI,GAAGE,CAAC,CAACL,KAAK,EAAE;IACxC,OAAO,KAAK;EACd;EACA,IAAIK,CAAC,CAACP,GAAG,GAAGQ,CAAC,CAACJ,MAAM,IAAII,CAAC,CAACR,GAAG,GAAGO,CAAC,CAACH,MAAM,EAAE;IACxC,OAAO,KAAK;EACd;EACA,OAAO,IAAI;AACb;AACA,SAASrG,YAAYA,CAAC0F,KAAK,EAAE3F,MAAM,EAAE;EACnC,IAAI2G,IAAI,GAAG3G,MAAM,CAAC4G,qBAAqB,CAAC,CAAC;EACzC,IAAIC,SAAS,GAAGnB,kBAAkB,CAACC,KAAK,CAAC;EACzC,OAAOa,wBAAwB,CAACG,IAAI,EAAEE,SAAS,CAAC;AAClD;AACA,SAAStD,oBAAoBA,CAACvD,MAAM,EAAE;EACpC,OAAO,EAAEA,MAAM,YAAY8G,WAAW,CAAC,IAAI,CAAC9G,MAAM,CAAC8E,YAAY,CAAC,WAAW,CAAC;AAC9E;AACA,SAASjD,4BAA4BA,CAAC7B,MAAM,EAAE8B,GAAG,EAAE;EACjD,IAAI9B,MAAM,YAAYmF,gBAAgB,EAAE;IACtC,OAAO,CAACC,eAAe,CAACpF,MAAM,EAAE8B,GAAG,CAAC;EACtC;EACA,IAAI9B,MAAM,YAAY+G,iBAAiB,EAAE;IACvC,OAAO/G,MAAM,CAACgH,IAAI,KAAK,QAAQ,IAAIhH,MAAM,CAACgH,IAAI,KAAK,OAAO;EAC5D;EACA,IAAIlE,gBAAgB,CAAC9C,MAAM,CAAC,EAAE;IAC5B,OAAO,KAAK;EACd;EACA,OAAO,IAAI;AACb;AACA,IAAIiH,iBAAiB,GAAG,eAAgB,IAAIC,GAAG,CAAC,CAC9C,UAAU,EACV,OAAO,EACP,OAAO,EACP,OAAO,EACP,MAAM,EACN,OAAO,EACP,QAAQ,EACR,QAAQ,EACR,OAAO,CACR,CAAC;AACF,SAAS9B,eAAeA,CAACpF,MAAM,EAAE8B,GAAG,EAAE;EACpC,OAAO9B,MAAM,CAACgH,IAAI,KAAK,UAAU,IAAIhH,MAAM,CAACgH,IAAI,KAAK,OAAO,GAAGlF,GAAG,KAAK,GAAG,GAAGmF,iBAAiB,CAACE,GAAG,CAACnH,MAAM,CAACgH,IAAI,CAAC;AACjH;AACA,SACEtI,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}