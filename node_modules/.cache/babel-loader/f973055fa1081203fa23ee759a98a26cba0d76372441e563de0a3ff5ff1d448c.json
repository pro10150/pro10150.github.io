{"ast":null,"code":"import _classCallCheck from \"C:/Users/pk117/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/pk117/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _objectSpread from \"C:/Users/pk117/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"C:/Users/pk117/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { flushSync as $eCAIO$flushSync } from \"react-dom\";\nimport { useRef as $eCAIO$useRef, useEffect as $eCAIO$useEffect, useMemo as $eCAIO$useMemo } from \"react\";\nimport { getFocusableTreeWalker as $eCAIO$getFocusableTreeWalker, focusSafely as $eCAIO$focusSafely } from \"@react-aria/focus\";\nimport { useRouter as $eCAIO$useRouter, focusWithoutScrolling as $eCAIO$focusWithoutScrolling, useEvent as $eCAIO$useEvent, scrollIntoViewport as $eCAIO$scrollIntoViewport, scrollIntoView as $eCAIO$scrollIntoView, mergeProps as $eCAIO$mergeProps, isAppleDevice as $eCAIO$isAppleDevice, isMac as $eCAIO$isMac, openLink as $eCAIO$openLink, isScrollable as $eCAIO$isScrollable } from \"@react-aria/utils\";\nimport { getInteractionModality as $eCAIO$getInteractionModality, usePress as $eCAIO$usePress, useLongPress as $eCAIO$useLongPress } from \"@react-aria/interactions\";\nimport { useLocale as $eCAIO$useLocale, useCollator as $eCAIO$useCollator } from \"@react-aria/i18n\";\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n    * Copyright 2020 Adobe. All rights reserved.\r\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n    * you may not use this file except in compliance with the License. You may obtain a copy\r\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n    *\r\n    * Unless required by applicable law or agreed to in writing, software distributed under\r\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n    * OF ANY KIND, either express or implied. See the License for the specific language\r\n    * governing permissions and limitations under the License.\r\n    */\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\nfunction $feb5ffebff200149$export$d3e3bd3e26688c04(e) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return (0, $eCAIO$isAppleDevice)() ? e.altKey : e.ctrlKey;\n}\nfunction $feb5ffebff200149$export$16792effe837dba3(e) {\n  if ((0, $eCAIO$isMac)()) return e.metaKey;\n  return e.ctrlKey;\n}\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n/**\r\n * Controls how long to wait before clearing the typeahead buffer.\r\n */\nvar $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\nfunction $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {\n  var keyboardDelegate = options.keyboardDelegate,\n    selectionManager = options.selectionManager,\n    onTypeSelect = options.onTypeSelect;\n  var state = (0, $eCAIO$useRef)({\n    search: \"\",\n    timeout: null\n  }).current;\n  var onKeyDown = function onKeyDown(e) {\n    var character = $fb3050f43d946246$var$getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target)) return;\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === \" \" && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!(\"continuePropagation\" in e)) e.stopPropagation();\n    }\n    state.search += character;\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    var key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n    // If no key found, search from the top.\n    if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) onTypeSelect(key);\n    }\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function () {\n      state.search = \"\";\n    }, $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\nfunction $fb3050f43d946246$var$getStringForKey(key) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;\n  return \"\";\n}\nfunction $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {\n  var manager = options.selectionManager,\n    delegate = options.keyboardDelegate,\n    ref = options.ref,\n    _options$autoFocus = options.autoFocus,\n    autoFocus = _options$autoFocus === void 0 ? false : _options$autoFocus,\n    _options$shouldFocusW = options.shouldFocusWrap,\n    shouldFocusWrap = _options$shouldFocusW === void 0 ? false : _options$shouldFocusW,\n    _options$disallowEmpt = options.disallowEmptySelection,\n    disallowEmptySelection = _options$disallowEmpt === void 0 ? false : _options$disallowEmpt,\n    _options$disallowSele = options.disallowSelectAll,\n    disallowSelectAll = _options$disallowSele === void 0 ? false : _options$disallowSele,\n    _options$selectOnFocu = options.selectOnFocus,\n    selectOnFocus = _options$selectOnFocu === void 0 ? manager.selectionBehavior === \"replace\" : _options$selectOnFocu,\n    _options$disallowType = options.disallowTypeAhead,\n    disallowTypeAhead = _options$disallowType === void 0 ? false : _options$disallowType,\n    shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n    _options$allowsTabNav = options.allowsTabNavigation,\n    allowsTabNavigation = _options$allowsTabNav === void 0 ? false : _options$allowsTabNav,\n    isVirtualized = options.isVirtualized,\n    _options$scrollRef = options.scrollRef,\n    scrollRef = _options$scrollRef === void 0 ? ref : _options$scrollRef,\n    _options$linkBehavior = options.linkBehavior,\n    linkBehavior = _options$linkBehavior === void 0 ? \"action\" : _options$linkBehavior;\n  var _ref = (0, $eCAIO$useLocale)(),\n    direction = _ref.direction;\n  var router = (0, $eCAIO$useRouter)();\n  var onKeyDown = function onKeyDown(e) {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === \"Tab\") e.preventDefault();\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target)) return;\n    var navigateToKey = function navigateToKey(key, childFocus) {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === \"selection\" && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          (0, $eCAIO$flushSync)(function () {\n            manager.setFocusedKey(key, childFocus);\n          });\n          var item = scrollRef.current.querySelector(\"[data-key=\\\"\".concat(CSS.escape(key.toString()), \"\\\"]\"));\n          router.open(item, e);\n          return;\n        }\n        manager.setFocusedKey(key, childFocus);\n        if (manager.isLink(key) && linkBehavior === \"override\") return;\n        if (e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(key);else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.replaceSelection(key);\n      }\n    };\n    switch (e.key) {\n      case \"ArrowDown\":\n        if (delegate.getKeyBelow) {\n          var _delegate_getFirstKey, _delegate_getFirstKey1;\n          e.preventDefault();\n          var nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"ArrowUp\":\n        if (delegate.getKeyAbove) {\n          var _delegate_getLastKey, _delegate_getLastKey1;\n          e.preventDefault();\n          var _nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);\n          if (_nextKey == null && shouldFocusWrap) _nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);\n          navigateToKey(_nextKey);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (delegate.getKeyLeftOf) {\n          var _delegate_getFirstKey2, _delegate_getLastKey2;\n          e.preventDefault();\n          var _nextKey2 = delegate.getKeyLeftOf(manager.focusedKey);\n          if (_nextKey2 == null && shouldFocusWrap) _nextKey2 = direction === \"rtl\" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);\n          navigateToKey(_nextKey2, direction === \"rtl\" ? \"first\" : \"last\");\n        }\n        break;\n      case \"ArrowRight\":\n        if (delegate.getKeyRightOf) {\n          var _delegate_getLastKey3, _delegate_getFirstKey3;\n          e.preventDefault();\n          var _nextKey3 = delegate.getKeyRightOf(manager.focusedKey);\n          if (_nextKey3 == null && shouldFocusWrap) _nextKey3 = direction === \"rtl\" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);\n          navigateToKey(_nextKey3, direction === \"rtl\" ? \"last\" : \"first\");\n        }\n        break;\n      case \"Home\":\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          var firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(firstKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n        }\n        break;\n      case \"End\":\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          var lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(lastKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n        }\n        break;\n      case \"PageDown\":\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          var _nextKey4 = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(_nextKey4);\n        }\n        break;\n      case \"PageUp\":\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          var _nextKey5 = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(_nextKey5);\n        }\n        break;\n      case \"a\":\n        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && manager.selectionMode === \"multiple\" && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case \"Escape\":\n        e.preventDefault();\n        if (!disallowEmptySelection) manager.clearSelection();\n        break;\n      case \"Tab\":\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) ref.current.focus();else {\n            var walker = (0, $eCAIO$getFocusableTreeWalker)(ref.current, {\n              tabbable: true\n            });\n            var next;\n            var last;\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n            if (next && !next.contains(document.activeElement)) (0, $eCAIO$focusWithoutScrolling)(next);\n          }\n          break;\n        }\n    }\n  };\n  // Store the scroll position so we can restore it later.\n  var scrollPos = (0, $eCAIO$useRef)({\n    top: 0,\n    left: 0\n  });\n  (0, $eCAIO$useEvent)(scrollRef, \"scroll\", isVirtualized ? null : function () {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n  var onFocus = function onFocus(e) {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    }\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n    if (manager.focusedKey == null) {\n      var navigateToFirstKey = function navigateToFirstKey(key) {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) manager.replaceSelection(key);\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      var relatedTarget = e.relatedTarget;\n      var _manager_lastSelectedKey, _manager_firstSelectedKey;\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n    if (!isVirtualized && manager.focusedKey != null) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      var element = scrollRef.current.querySelector(\"[data-key=\\\"\".concat(CSS.escape(manager.focusedKey.toString()), \"\\\"]\"));\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement)) (0, $eCAIO$focusWithoutScrolling)(element);\n        var modality = (0, $eCAIO$getInteractionModality)();\n        if (modality === \"keyboard\") (0, $eCAIO$scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n  };\n  var onBlur = function onBlur(e) {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n  var autoFocusRef = (0, $eCAIO$useRef)(autoFocus);\n  (0, $eCAIO$useEffect)(function () {\n    if (autoFocusRef.current) {\n      var focusedKey = null;\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === \"first\") focusedKey = delegate.getFirstKey();\n      if (autoFocus === \"last\") focusedKey = delegate.getLastKey();\n      // If there are any selected keys, make the first one the new focus target\n      var selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        var _iterator = _createForOfIteratorHelper(selectedKeys),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var key = _step.value;\n            if (manager.canSelectItem(key)) {\n              focusedKey = key;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) (0, $eCAIO$focusSafely)(ref.current);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  var lastFocusedKey = (0, $eCAIO$useRef)(manager.focusedKey);\n  (0, $eCAIO$useEffect)(function () {\n    var modality = (0, $eCAIO$getInteractionModality)();\n    if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n      var element = scrollRef.current.querySelector(\"[data-key=\\\"\".concat(CSS.escape(manager.focusedKey.toString()), \"\\\"]\"));\n      if (element && (modality === \"keyboard\" || autoFocusRef.current)) {\n        if (!isVirtualized) (0, $eCAIO$scrollIntoView)(scrollRef.current, element);\n        (0, $eCAIO$scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) (0, $eCAIO$focusSafely)(ref.current);\n    lastFocusedKey.current = manager.focusedKey;\n    autoFocusRef.current = false;\n  }, [isVirtualized, scrollRef, manager.focusedKey, manager.isFocused, ref]);\n  var handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown: function onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target)\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n    }\n  };\n  var _ref2 = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({\n      keyboardDelegate: delegate,\n      selectionManager: manager\n    }),\n    typeSelectProps = _ref2.typeSelectProps;\n  if (!disallowTypeAhead) handlers = (0, $eCAIO$mergeProps)(typeSelectProps, handlers);\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  var tabIndex;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  return {\n    collectionProps: _objectSpread(_objectSpread({}, handlers), {}, {\n      tabIndex: tabIndex\n    })\n  };\n}\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n\nfunction $880e95eb8b93ba9a$export$ecf600387e221c37(options) {\n  var manager = options.selectionManager,\n    key = options.key,\n    ref = options.ref,\n    shouldSelectOnPressUp = options.shouldSelectOnPressUp,\n    shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n    focus = options.focus,\n    isDisabled = options.isDisabled,\n    onAction = options.onAction,\n    allowsDifferentPressOrigin = options.allowsDifferentPressOrigin,\n    _options$linkBehavior2 = options.linkBehavior,\n    linkBehavior = _options$linkBehavior2 === void 0 ? \"action\" : _options$linkBehavior2;\n  var router = (0, $eCAIO$useRouter)();\n  var onSelect = function onSelect(e) {\n    if (e.pointerType === \"keyboard\" && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.toggleSelection(key);else {\n      if (manager.selectionMode === \"none\") return;\n      if (manager.isLink(key)) {\n        if (linkBehavior === \"selection\") {\n          router.open(ref.current, e);\n          // Always set selected keys back to what they were so that select and combobox close.\n          manager.setSelectedKeys(manager.selectedKeys);\n          return;\n        } else if (linkBehavior === \"override\" || linkBehavior === \"none\") return;\n      }\n      if (manager.selectionMode === \"single\") {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);else manager.replaceSelection(key);\n      } else if (e && e.shiftKey) manager.extendSelection(key);else if (manager.selectionBehavior === \"toggle\" || e && ((0, $feb5ffebff200149$export$16792effe837dba3)(e) || e.pointerType === \"touch\" || e.pointerType === \"virtual\"))\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);else manager.replaceSelection(key);\n    }\n  };\n  // Focus the associated DOM node when this item becomes the focusedKey\n  (0, $eCAIO$useEffect)(function () {\n    var isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {\n      if (focus) focus();else if (document.activeElement !== ref.current) (0, $eCAIO$focusSafely)(ref.current);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  var itemProps = {};\n  if (!shouldUseVirtualFocus && !isDisabled) itemProps = {\n    tabIndex: key === manager.focusedKey ? 0 : -1,\n    onFocus: function onFocus(e) {\n      if (e.target === ref.current) manager.setFocusedKey(key);\n    }\n  };else if (isDisabled) itemProps.onMouseDown = function (e) {\n    // Prevent focus going to the body when clicking on a disabled item.\n    e.preventDefault();\n  };\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  var isLinkOverride = manager.isLink(key) && linkBehavior === \"override\";\n  var hasLinkAction = manager.isLink(key) && linkBehavior !== \"selection\" && linkBehavior !== \"none\";\n  var allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;\n  var allowsActions = (onAction || hasLinkAction) && !isDisabled;\n  var hasPrimaryAction = allowsActions && (manager.selectionBehavior === \"replace\" ? !allowsSelection : !allowsSelection || manager.isEmpty);\n  var hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === \"replace\";\n  var hasAction = hasPrimaryAction || hasSecondaryAction;\n  var modality = (0, $eCAIO$useRef)(null);\n  var longPressEnabled = hasAction && allowsSelection;\n  var longPressEnabledOnPressStart = (0, $eCAIO$useRef)(false);\n  var hadPrimaryActionOnPressStart = (0, $eCAIO$useRef)(false);\n  var performAction = function performAction(e) {\n    if (onAction) onAction();\n    if (hasLinkAction) router.open(ref.current, e);\n  };\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  var itemPressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = function (e) {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === \"keyboard\" && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    };\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) itemPressProps.onPress = function (e) {\n      if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== \"mouse\") {\n        if (e.pointerType === \"keyboard\" && !$880e95eb8b93ba9a$var$isActionKey()) return;\n        performAction(e);\n      } else if (e.pointerType !== \"keyboard\" && allowsSelection) onSelect(e);\n    };else {\n      itemPressProps.onPressUp = hasPrimaryAction ? null : function (e) {\n        if (e.pointerType !== \"keyboard\" && allowsSelection) onSelect(e);\n      };\n      itemPressProps.onPress = hasPrimaryAction ? performAction : null;\n    }\n  } else {\n    itemPressProps.onPressStart = function (e) {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (allowsSelection && (e.pointerType === \"mouse\" && !hasPrimaryAction || e.pointerType === \"keyboard\" && (!allowsActions || $880e95eb8b93ba9a$var$isSelectionKey()))) onSelect(e);\n    };\n    itemPressProps.onPress = function (e) {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (e.pointerType === \"touch\" || e.pointerType === \"pen\" || e.pointerType === \"virtual\" || e.pointerType === \"keyboard\" && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e.pointerType === \"mouse\" && hadPrimaryActionOnPressStart.current) {\n        if (hasAction) performAction(e);else if (allowsSelection) onSelect(e);\n      }\n    };\n  }\n  itemProps[\"data-key\"] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  var _ref3 = (0, $eCAIO$usePress)(itemPressProps),\n    pressProps = _ref3.pressProps,\n    isPressed = _ref3.isPressed;\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  var onDoubleClick = hasSecondaryAction ? function (e) {\n    if (modality.current === \"mouse\") {\n      e.stopPropagation();\n      e.preventDefault();\n      performAction(e);\n    }\n  } : undefined;\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  var _ref4 = (0, $eCAIO$useLongPress)({\n      isDisabled: !longPressEnabled,\n      onLongPress: function onLongPress(e) {\n        if (e.pointerType === \"touch\") {\n          onSelect(e);\n          manager.setSelectionBehavior(\"toggle\");\n        }\n      }\n    }),\n    longPressProps = _ref4.longPressProps;\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  var onDragStartCapture = function onDragStartCapture(e) {\n    if (modality.current === \"touch\" && longPressEnabledOnPressStart.current) e.preventDefault();\n  };\n  // Prevent default on link clicks so that we control exactly\n  // when they open (to match selection behavior).\n  var onClick = manager.isLink(key) ? function (e) {\n    if (!(0, $eCAIO$openLink).isOpening) e.preventDefault();\n  } : undefined;\n  return {\n    itemProps: (0, $eCAIO$mergeProps)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {\n      onDoubleClick: onDoubleClick,\n      onDragStartCapture: onDragStartCapture,\n      onClick: onClick\n    }),\n    isPressed: isPressed,\n    isSelected: manager.isSelected(key),\n    isFocused: manager.isFocused && manager.focusedKey === key,\n    isDisabled: isDisabled,\n    allowsSelection: allowsSelection,\n    hasAction: hasAction\n  };\n}\nfunction $880e95eb8b93ba9a$var$isActionKey() {\n  var event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === \"Enter\";\n}\nfunction $880e95eb8b93ba9a$var$isSelectionKey() {\n  var event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === \" \" || (event === null || event === void 0 ? void 0 : event.code) === \"Space\";\n}\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\nvar $2a25aae57d74318e$export$a05409b8bb224a5a = /*#__PURE__*/function () {\n  function $2a25aae57d74318e$export$a05409b8bb224a5a() {\n    _classCallCheck(this, $2a25aae57d74318e$export$a05409b8bb224a5a);\n    if (arguments.length === 1) {\n      var opts = arguments.length <= 0 ? undefined : arguments[0];\n      this.collection = opts.collection;\n      this.ref = opts.ref;\n      this.collator = opts.collator;\n      this.disabledKeys = opts.disabledKeys || new Set();\n      this.orientation = opts.orientation;\n      this.direction = opts.direction;\n      this.layout = opts.layout || \"stack\";\n    } else {\n      this.collection = arguments.length <= 0 ? undefined : arguments[0];\n      this.disabledKeys = arguments.length <= 1 ? undefined : arguments[1];\n      this.ref = arguments.length <= 2 ? undefined : arguments[2];\n      this.collator = arguments.length <= 3 ? undefined : arguments[3];\n      this.layout = \"stack\";\n      this.orientation = \"vertical\";\n    }\n    // If this is a vertical stack, remove the left/right methods completely\n    // so they aren't called by useDroppableCollection.\n    if (this.layout === \"stack\" && this.orientation === \"vertical\") {\n      this.getKeyLeftOf = undefined;\n      this.getKeyRightOf = undefined;\n    }\n  }\n  _createClass($2a25aae57d74318e$export$a05409b8bb224a5a, [{\n    key: \"getNextKey\",\n    value: function getNextKey(key) {\n      key = this.collection.getKeyAfter(key);\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyAfter(key);\n      }\n      return null;\n    }\n  }, {\n    key: \"getPreviousKey\",\n    value: function getPreviousKey(key) {\n      key = this.collection.getKeyBefore(key);\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyBefore(key);\n      }\n      return null;\n    }\n  }, {\n    key: \"findKey\",\n    value: function findKey(key, nextKey, shouldSkip) {\n      var item = this.getItem(key);\n      if (!item) return null;\n      // Find the item above or below in the same column.\n      var prevRect = item.getBoundingClientRect();\n      do {\n        key = nextKey(key);\n        item = this.getItem(key);\n      } while (item && shouldSkip(prevRect, item.getBoundingClientRect()));\n      return key;\n    }\n  }, {\n    key: \"isSameRow\",\n    value: function isSameRow(prevRect, itemRect) {\n      return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;\n    }\n  }, {\n    key: \"isSameColumn\",\n    value: function isSameColumn(prevRect, itemRect) {\n      return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;\n    }\n  }, {\n    key: \"getKeyBelow\",\n    value: function getKeyBelow(key) {\n      var _this = this;\n      if (this.layout === \"grid\" && this.orientation === \"vertical\") return this.findKey(key, function (key) {\n        return _this.getNextKey(key);\n      }, this.isSameRow);else return this.getNextKey(key);\n    }\n  }, {\n    key: \"getKeyAbove\",\n    value: function getKeyAbove(key) {\n      var _this2 = this;\n      if (this.layout === \"grid\" && this.orientation === \"vertical\") return this.findKey(key, function (key) {\n        return _this2.getPreviousKey(key);\n      }, this.isSameRow);else return this.getPreviousKey(key);\n    }\n  }, {\n    key: \"getNextColumn\",\n    value: function getNextColumn(key, right) {\n      return right ? this.getPreviousKey(key) : this.getNextKey(key);\n    }\n  }, {\n    key: \"getKeyRightOf\",\n    value: function getKeyRightOf(key) {\n      var _this3 = this;\n      if (this.layout === \"grid\") {\n        if (this.orientation === \"vertical\") return this.getNextColumn(key, this.direction === \"rtl\");else return this.findKey(key, function (key) {\n          return _this3.getNextColumn(key, _this3.direction === \"rtl\");\n        }, this.isSameColumn);\n      } else if (this.orientation === \"horizontal\") return this.getNextColumn(key, this.direction === \"rtl\");\n      return null;\n    }\n  }, {\n    key: \"getKeyLeftOf\",\n    value: function getKeyLeftOf(key) {\n      var _this4 = this;\n      if (this.layout === \"grid\") {\n        if (this.orientation === \"vertical\") return this.getNextColumn(key, this.direction === \"ltr\");else return this.findKey(key, function (key) {\n          return _this4.getNextColumn(key, _this4.direction === \"ltr\");\n        }, this.isSameColumn);\n      } else if (this.orientation === \"horizontal\") return this.getNextColumn(key, this.direction === \"ltr\");\n      return null;\n    }\n  }, {\n    key: \"getFirstKey\",\n    value: function getFirstKey() {\n      var key = this.collection.getFirstKey();\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyAfter(key);\n      }\n      return null;\n    }\n  }, {\n    key: \"getLastKey\",\n    value: function getLastKey() {\n      var key = this.collection.getLastKey();\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyBefore(key);\n      }\n      return null;\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this.ref.current.querySelector(\"[data-key=\\\"\".concat(CSS.escape(key.toString()), \"\\\"]\"));\n    }\n  }, {\n    key: \"getKeyPageAbove\",\n    value: function getKeyPageAbove(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n      if (!item) return null;\n      if (!(0, $eCAIO$isScrollable)(menu)) return this.getFirstKey();\n      var containerRect = menu.getBoundingClientRect();\n      var itemRect = item.getBoundingClientRect();\n      if (this.orientation === \"horizontal\") {\n        var containerX = containerRect.x - menu.scrollLeft;\n        var pageX = Math.max(0, itemRect.x - containerX + itemRect.width - containerRect.width);\n        while (item && itemRect.x - containerX > pageX) {\n          key = this.getKeyAbove(key);\n          item = key == null ? null : this.getItem(key);\n          itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n        }\n      } else {\n        var containerY = containerRect.y - menu.scrollTop;\n        var pageY = Math.max(0, itemRect.y - containerY + itemRect.height - containerRect.height);\n        while (item && itemRect.y - containerY > pageY) {\n          key = this.getKeyAbove(key);\n          item = key == null ? null : this.getItem(key);\n          itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n        }\n      }\n      return key !== null && key !== void 0 ? key : this.getFirstKey();\n    }\n  }, {\n    key: \"getKeyPageBelow\",\n    value: function getKeyPageBelow(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n      if (!item) return null;\n      if (!(0, $eCAIO$isScrollable)(menu)) return this.getLastKey();\n      var containerRect = menu.getBoundingClientRect();\n      var itemRect = item.getBoundingClientRect();\n      if (this.orientation === \"horizontal\") {\n        var containerX = containerRect.x - menu.scrollLeft;\n        var pageX = Math.min(menu.scrollWidth, itemRect.x - containerX - itemRect.width + containerRect.width);\n        while (item && itemRect.x - containerX < pageX) {\n          key = this.getKeyBelow(key);\n          item = key == null ? null : this.getItem(key);\n          itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n        }\n      } else {\n        var containerY = containerRect.y - menu.scrollTop;\n        var pageY = Math.min(menu.scrollHeight, itemRect.y - containerY - itemRect.height + containerRect.height);\n        while (item && itemRect.y - containerY < pageY) {\n          key = this.getKeyBelow(key);\n          item = key == null ? null : this.getItem(key);\n          itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n        }\n      }\n      return key !== null && key !== void 0 ? key : this.getLastKey();\n    }\n  }, {\n    key: \"getKeyForSearch\",\n    value: function getKeyForSearch(search, fromKey) {\n      if (!this.collator) return null;\n      var collection = this.collection;\n      var key = fromKey || this.getFirstKey();\n      while (key != null) {\n        var item = collection.getItem(key);\n        var substring = item.textValue.slice(0, search.length);\n        if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n        key = this.getKeyBelow(key);\n      }\n      return null;\n    }\n  }]);\n  return $2a25aae57d74318e$export$a05409b8bb224a5a;\n}();\nfunction $982254629710d113$export$b95089534ab7c1fd(props) {\n  var selectionManager = props.selectionManager,\n    collection = props.collection,\n    disabledKeys = props.disabledKeys,\n    ref = props.ref,\n    keyboardDelegate = props.keyboardDelegate;\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  var collator = (0, $eCAIO$useCollator)({\n    usage: \"search\",\n    sensitivity: \"base\"\n  });\n  var disabledBehavior = selectionManager.disabledBehavior;\n  var delegate = (0, $eCAIO$useMemo)(function () {\n    return keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(collection, disabledBehavior === \"selection\" ? new Set() : disabledKeys, ref, collator);\n  }, [keyboardDelegate, collection, disabledKeys, ref, collator, disabledBehavior]);\n  var _ref5 = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)(_objectSpread(_objectSpread({}, props), {}, {\n      ref: ref,\n      selectionManager: selectionManager,\n      keyboardDelegate: delegate\n    })),\n    collectionProps = _ref5.collectionProps;\n  return {\n    listProps: collectionProps\n  };\n}\nexport { $ae20dd8cbca75726$export$d6daf82dcd84e87c as useSelectableCollection, $880e95eb8b93ba9a$export$ecf600387e221c37 as useSelectableItem, $982254629710d113$export$b95089534ab7c1fd as useSelectableList, $2a25aae57d74318e$export$a05409b8bb224a5a as ListKeyboardDelegate, $fb3050f43d946246$export$e32c88dfddc6e1d8 as useTypeSelect };","map":{"version":3,"names":["$feb5ffebff200149$export$d3e3bd3e26688c04","e","$eCAIO$isAppleDevice","altKey","ctrlKey","$feb5ffebff200149$export$16792effe837dba3","$eCAIO$isMac","metaKey","$fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS","$fb3050f43d946246$export$e32c88dfddc6e1d8","options","keyboardDelegate","selectionManager","onTypeSelect","state","$eCAIO$useRef","search","timeout","current","onKeyDown","character","$fb3050f43d946246$var$getStringForKey","key","currentTarget","contains","target","trim","length","preventDefault","stopPropagation","getKeyForSearch","focusedKey","setFocusedKey","clearTimeout","setTimeout","typeSelectProps","onKeyDownCapture","test","$ae20dd8cbca75726$export$d6daf82dcd84e87c","manager","delegate","ref","_options$autoFocus","autoFocus","_options$shouldFocusW","shouldFocusWrap","_options$disallowEmpt","disallowEmptySelection","_options$disallowSele","disallowSelectAll","_options$selectOnFocu","selectOnFocus","selectionBehavior","_options$disallowType","disallowTypeAhead","shouldUseVirtualFocus","_options$allowsTabNav","allowsTabNavigation","isVirtualized","_options$scrollRef","scrollRef","_options$linkBehavior","linkBehavior","_ref","$eCAIO$useLocale","direction","router","$eCAIO$useRouter","navigateToKey","childFocus","isLink","$eCAIO$flushSync","item","querySelector","concat","CSS","escape","toString","open","shiftKey","selectionMode","extendSelection","replaceSelection","getKeyBelow","_delegate_getFirstKey","_delegate_getFirstKey1","nextKey","getFirstKey","call","getKeyAbove","_delegate_getLastKey","_delegate_getLastKey1","getLastKey","getKeyLeftOf","_delegate_getFirstKey2","_delegate_getLastKey2","getKeyRightOf","_delegate_getLastKey3","_delegate_getFirstKey3","firstKey","lastKey","getKeyPageBelow","getKeyPageAbove","selectAll","clearSelection","focus","walker","$eCAIO$getFocusableTreeWalker","tabbable","next","last","lastChild","document","activeElement","$eCAIO$focusWithoutScrolling","scrollPos","top","left","$eCAIO$useEvent","scrollTop","scrollLeft","onFocus","isFocused","setFocused","navigateToFirstKey","relatedTarget","_manager_lastSelectedKey","_manager_firstSelectedKey","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","firstSelectedKey","element","modality","$eCAIO$getInteractionModality","$eCAIO$scrollIntoViewport","containingElement","onBlur","autoFocusRef","$eCAIO$useEffect","selectedKeys","size","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","canSelectItem","err","f","$eCAIO$focusSafely","lastFocusedKey","$eCAIO$scrollIntoView","handlers","onMouseDown","_ref2","$eCAIO$mergeProps","tabIndex","collectionProps","_objectSpread","$880e95eb8b93ba9a$export$ecf600387e221c37","shouldSelectOnPressUp","isDisabled","onAction","allowsDifferentPressOrigin","_options$linkBehavior2","onSelect","pointerType","toggleSelection","setSelectedKeys","isSelected","childFocusStrategy","itemProps","isLinkOverride","hasLinkAction","allowsSelection","allowsActions","hasPrimaryAction","isEmpty","hasSecondaryAction","hasAction","longPressEnabled","longPressEnabledOnPressStart","hadPrimaryActionOnPressStart","performAction","itemPressProps","onPressStart","$880e95eb8b93ba9a$var$isSelectionKey","onPress","$880e95eb8b93ba9a$var$isActionKey","onPressUp","preventFocusOnPress","_ref3","$eCAIO$usePress","pressProps","isPressed","onDoubleClick","undefined","_ref4","$eCAIO$useLongPress","onLongPress","setSelectionBehavior","longPressProps","onDragStartCapture","onClick","$eCAIO$openLink","isOpening","event","window","code","$2a25aae57d74318e$export$a05409b8bb224a5a","_classCallCheck","arguments","opts","collection","collator","disabledKeys","Set","orientation","layout","_createClass","getNextKey","getKeyAfter","getItem","type","has","getPreviousKey","getKeyBefore","findKey","shouldSkip","prevRect","getBoundingClientRect","isSameRow","itemRect","isSameColumn","_this","_this2","getNextColumn","right","_this3","_this4","menu","$eCAIO$isScrollable","containerRect","containerX","x","pageX","Math","max","width","containerY","y","pageY","height","min","scrollWidth","scrollHeight","fromKey","substring","textValue","slice","compare","$982254629710d113$export$b95089534ab7c1fd","props","$eCAIO$useCollator","usage","sensitivity","disabledBehavior","$eCAIO$useMemo","_ref5","listProps"],"sources":["C:\\Users\\pk117\\Desktop\\Personal\\pro10150.github.io\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\index.ts","C:\\Users\\pk117\\Desktop\\Personal\\pro10150.github.io\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableCollection.ts","C:\\Users\\pk117\\Desktop\\Personal\\pro10150.github.io\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\utils.ts","C:\\Users\\pk117\\Desktop\\Personal\\pro10150.github.io\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useTypeSelect.ts","C:\\Users\\pk117\\Desktop\\Personal\\pro10150.github.io\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableItem.ts","C:\\Users\\pk117\\Desktop\\Personal\\pro10150.github.io\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableList.ts","C:\\Users\\pk117\\Desktop\\Personal\\pro10150.github.io\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\ListKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useSelectableCollection} from './useSelectableCollection';\nexport {useSelectableItem} from './useSelectableItem';\nexport {useSelectableList} from './useSelectableList';\nexport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nexport {useTypeSelect} from './useTypeSelect';\n\nexport type {AriaSelectableCollectionOptions, SelectableCollectionAria} from './useSelectableCollection';\nexport type {AriaSelectableListOptions, SelectableListAria} from './useSelectableList';\nexport type {SelectableItemOptions, SelectableItemStates, SelectableItemAria} from './useSelectableItem';\nexport type {AriaTypeSelectOptions, TypeSelectAria} from './useTypeSelect';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, FocusStrategy, Key, KeyboardDelegate} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {FocusEvent, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, scrollIntoViewport, useEvent, useRouter} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\nexport interface AriaSelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override'\n}\n\nexport interface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: DOMAttributes\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: AriaSelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref,\n    linkBehavior = 'action'\n  } = options;\n  let {direction} = useLocale();\n  let router = useRouter();\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as Element)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === 'selection' && selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          flushSync(() => {\n            manager.setFocusedKey(key, childFocus);\n          });\n\n          let item = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n          router.open(item, e);\n\n          return;\n        }\n\n        manager.setFocusedKey(key, childFocus);\n\n        if (manager.isLink(key) && linkBehavior === 'override') {\n          return;\n        }\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getFirstKey?.(manager.focusedKey) : delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getLastKey?.(manager.focusedKey) : delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: FocusableElement;\n            let last: FocusableElement;\n            do {\n              last = walker.lastChild() as FocusableElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n\n    if (!isVirtualized && manager.focusedKey != null) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement)) {\n          focusWithoutScrolling(element);\n        }\n\n        let modality = getInteractionModality();\n        if (modality === 'keyboard') {\n          scrollIntoViewport(element, {containingElement: ref.current});\n        }\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        for (let key of selectedKeys) {\n          if (manager.canSelectItem(key)) {\n            focusedKey = key;\n            break;\n          }\n        }\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  let lastFocusedKey = useRef(manager.focusedKey);\n  useEffect(() => {\n    let modality = getInteractionModality();\n    if (manager.isFocused && manager.focusedKey != null && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`) as HTMLElement;\n      if (element && (modality === 'keyboard' || autoFocusRef.current)) {\n        if (!isVirtualized) {\n          scrollIntoView(scrollRef.current, element);\n        }\n        scrollIntoViewport(element, {containingElement: ref.current});\n      }\n    }\n\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) {\n      focusSafely(ref.current);\n    }\n\n    lastFocusedKey.current = manager.focusedKey;\n    autoFocusRef.current = false;\n  }, [isVirtualized, scrollRef, manager.focusedKey, manager.isFocused, ref]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice, isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, Key, KeyboardDelegate} from '@react-types/shared';\nimport {KeyboardEvent, useRef} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\n/**\n * Controls how long to wait before clearing the typeahead buffer.\n */\nconst TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\n\nexport interface AriaTypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\nexport interface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: DOMAttributes\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: AriaTypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, Key, LongPressEvent, PressEvent} from '@react-types/shared';\nimport {focusSafely} from '@react-aria/focus';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {mergeProps, openLink, useRouter} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\nimport {RefObject, useEffect, useRef} from 'react';\n\nexport interface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<FocusableElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether selection requires the pointer/mouse down and up events to occur on the same target or triggers selection on\n   * the target of the pointer/mouse up event.\n   */\n  allowsDifferentPressOrigin?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the item. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * - 'none': links are disabled for both selection and actions (e.g. handled elsewhere).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override' | 'none'\n}\n\nexport interface SelectableItemStates {\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /** Whether the item is currently focused. */\n  isFocused: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`.\n   */\n  allowsSelection: boolean,\n  /**\n   * Whether the item has an action, dependent on `onAction`, `disabledKeys`,\n   * and `disabledBehavior`. It may also change depending on the current selection state\n   * of the list (e.g. when selection is primary). This can be used to enable or disable hover\n   * styles or other visual indications of interactivity.\n   */\n  hasAction: boolean\n}\n\nexport interface SelectableItemAria extends SelectableItemStates {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: DOMAttributes\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction,\n    allowsDifferentPressOrigin,\n    linkBehavior = 'action'\n  } = options;\n  let router = useRouter();\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.isLink(key)) {\n        if (linkBehavior === 'selection') {\n          router.open(ref.current, e);\n          // Always set selected keys back to what they were so that select and combobox close.\n          manager.setSelectedKeys(manager.selectedKeys);\n          return;\n        } else if (linkBehavior === 'override' || linkBehavior === 'none') {\n          return;\n        }\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {\n      if (focus) {\n        focus();\n      } else if (document.activeElement !== ref.current) {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus && !isDisabled) {\n    itemProps = {\n      tabIndex: key === manager.focusedKey ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  } else if (isDisabled) {\n    itemProps.onMouseDown = (e) => {\n      // Prevent focus going to the body when clicking on a disabled item.\n      e.preventDefault();\n    };\n  }\n\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  let isLinkOverride = manager.isLink(key) && linkBehavior === 'override';\n  let hasLinkAction = manager.isLink(key) && linkBehavior !== 'selection' && linkBehavior !== 'none';\n  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;\n  let allowsActions = (onAction || hasLinkAction) && !isDisabled;\n  let hasPrimaryAction = allowsActions && (\n    manager.selectionBehavior === 'replace'\n      ? !allowsSelection\n      : !allowsSelection || manager.isEmpty\n  );\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = useRef(null);\n\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = useRef(false);\n  let hadPrimaryActionOnPressStart = useRef(false);\n\n  let performAction = (e) => {\n    if (onAction) {\n      onAction();\n    }\n\n    if (hasLinkAction) {\n      router.open(ref.current, e);\n    }\n  };\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || isSelectionKey())) {\n        onSelect(e);\n      }\n    };\n\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) {\n      itemPressProps.onPress = (e) => {\n        if (hasPrimaryAction || (hasSecondaryAction && e.pointerType !== 'mouse')) {\n          if (e.pointerType === 'keyboard' && !isActionKey()) {\n            return;\n          }\n\n          performAction(e);\n        } else if (e.pointerType !== 'keyboard' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n    } else {\n      itemPressProps.onPressUp = hasPrimaryAction ? null : (e) => {\n        if (e.pointerType !== 'keyboard' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? performAction : null;\n    }\n  } else {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (\n        allowsSelection && (\n          (e.pointerType === 'mouse' && !hasPrimaryAction) ||\n          (e.pointerType === 'keyboard' && (!allowsActions || isSelectionKey()))\n        )\n      ) {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (\n        e.pointerType === 'touch' ||\n        e.pointerType === 'pen' ||\n        e.pointerType === 'virtual' ||\n        (e.pointerType === 'keyboard' && hasAction && isActionKey()) ||\n        (e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current)\n      ) {\n        if (hasAction) {\n          performAction(e);\n        } else if (allowsSelection) {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      performAction(e);\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {longPressProps} = useLongPress({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) {\n      e.preventDefault();\n    }\n  };\n\n  // Prevent default on link clicks so that we control exactly\n  // when they open (to match selection behavior).\n  let onClick = manager.isLink(key) ? e => {\n    if (!(openLink as any).isOpening) {\n      e.preventDefault();\n    }\n  } : undefined;\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      longPressEnabled ? longPressProps : {},\n      {onDoubleClick, onDragStartCapture, onClick}\n    ),\n    isPressed,\n    isSelected: manager.isSelected(key),\n    isFocused: manager.isFocused && manager.focusedKey === key,\n    isDisabled,\n    allowsSelection,\n    hasAction\n  };\n}\n\nfunction isActionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === 'Enter';\n}\n\nfunction isSelectionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === ' ' || event?.code === 'Space';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSelectableCollectionOptions, useSelectableCollection} from './useSelectableCollection';\nimport {Collection, DOMAttributes, Key, KeyboardDelegate, Node} from '@react-types/shared';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {useCollator} from '@react-aria/i18n';\nimport {useMemo} from 'react';\n\nexport interface AriaSelectableListOptions extends Omit<AriaSelectableCollectionOptions, 'keyboardDelegate'> {\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>\n}\n\nexport interface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: DOMAttributes\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: AriaSelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let disabledBehavior = selectionManager.disabledBehavior;\n  let delegate = useMemo(() => (\n    keyboardDelegate || new ListKeyboardDelegate(collection, disabledBehavior === 'selection' ? new Set() : disabledKeys, ref, collator)\n  ), [keyboardDelegate, collection, disabledKeys, ref, collator, disabledBehavior]);\n\n  let {collectionProps} = useSelectableCollection({\n    ...props,\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Direction, Key, KeyboardDelegate, Node, Orientation} from '@react-types/shared';\nimport {isScrollable} from '@react-aria/utils';\nimport {RefObject} from 'react';\n\ninterface ListKeyboardDelegateOptions<T> {\n  collection: Collection<Node<T>>,\n  ref: RefObject<HTMLElement>,\n  collator?: Intl.Collator,\n  layout?: 'stack' | 'grid',\n  orientation?: Orientation,\n  direction?: Direction,\n  disabledKeys?: Set<Key>\n}\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator | undefined;\n  private layout: 'stack' | 'grid';\n  private orientation?: Orientation;\n  private direction?: Direction;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator);\n  constructor(options: ListKeyboardDelegateOptions<T>);\n  constructor(...args: any[]) {\n    if (args.length === 1) {\n      let opts = args[0] as ListKeyboardDelegateOptions<T>;\n      this.collection = opts.collection;\n      this.ref = opts.ref;\n      this.collator = opts.collator;\n      this.disabledKeys = opts.disabledKeys || new Set();\n      this.orientation = opts.orientation;\n      this.direction = opts.direction;\n      this.layout = opts.layout || 'stack';\n    } else {\n      this.collection = args[0];\n      this.disabledKeys = args[1];\n      this.ref = args[2];\n      this.collator = args[3];\n      this.layout = 'stack';\n      this.orientation = 'vertical';\n    }\n\n    // If this is a vertical stack, remove the left/right methods completely\n    // so they aren't called by useDroppableCollection.\n    if (this.layout === 'stack' && this.orientation === 'vertical') {\n      this.getKeyLeftOf = undefined;\n      this.getKeyRightOf = undefined;\n    }\n  }\n\n  getNextKey(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return null;\n  }\n\n  getPreviousKey(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n\n    return null;\n  }\n\n  private findKey(\n    key: Key,\n    nextKey: (key: Key) => Key,\n    shouldSkip: (prevRect: DOMRect, itemRect: DOMRect) => boolean\n  ) {\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    // Find the item above or below in the same column.\n    let prevRect = item.getBoundingClientRect();\n    do {\n      key = nextKey(key);\n      item = this.getItem(key);\n    } while (item && shouldSkip(prevRect, item.getBoundingClientRect()));\n\n    return key;\n  }\n\n  private isSameRow(prevRect: DOMRect, itemRect: DOMRect) {\n    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;\n  }\n\n  private isSameColumn(prevRect: DOMRect, itemRect: DOMRect) {\n    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;\n  }\n\n  getKeyBelow(key: Key) {\n    if (this.layout === 'grid' && this.orientation === 'vertical') {\n      return this.findKey(key, (key) => this.getNextKey(key), this.isSameRow);\n    } else {\n      return this.getNextKey(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    if (this.layout === 'grid' && this.orientation === 'vertical') {\n      return this.findKey(key, (key) => this.getPreviousKey(key), this.isSameRow);\n    } else {\n      return this.getPreviousKey(key);\n    }\n  }\n\n  private getNextColumn(key: Key, right: boolean) {\n    return right ? this.getPreviousKey(key) : this.getNextKey(key);\n  }\n\n  getKeyRightOf(key: Key) {\n    if (this.layout === 'grid') {\n      if (this.orientation === 'vertical') {\n        return this.getNextColumn(key, this.direction === 'rtl');\n      } else {\n        return this.findKey(key, (key) => this.getNextColumn(key, this.direction === 'rtl'), this.isSameColumn);\n      }\n    } else if (this.orientation === 'horizontal') {\n      return this.getNextColumn(key, this.direction === 'rtl');\n    }\n\n    return null;\n  }\n\n  getKeyLeftOf(key: Key) {\n    if (this.layout === 'grid') {\n      if (this.orientation === 'vertical') {\n        return this.getNextColumn(key, this.direction === 'ltr');\n      } else {\n        return this.findKey(key, (key) => this.getNextColumn(key, this.direction === 'ltr'), this.isSameColumn);\n      }\n    } else if (this.orientation === 'horizontal') {\n      return this.getNextColumn(key, this.direction === 'ltr');\n    }\n\n    return null;\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return null;\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n\n    return null;\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    if (!isScrollable(menu)) {\n      return this.getFirstKey();\n    }\n\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === 'horizontal') {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.max(0, (itemRect.x - containerX) + itemRect.width - containerRect.width);\n\n      while (item && (itemRect.x - containerX) > pageX) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.max(0, (itemRect.y - containerY) + itemRect.height - containerRect.height);\n\n      while (item && (itemRect.y - containerY) > pageY) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    }\n\n    return key ?? this.getFirstKey();\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    if (!isScrollable(menu)) {\n      return this.getLastKey();\n    }\n\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === 'horizontal') {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.min(menu.scrollWidth, (itemRect.x - containerX) - itemRect.width + containerRect.width);\n\n      while (item && (itemRect.x - containerX) < pageX) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.min(menu.scrollHeight, (itemRect.y - containerY) - itemRect.height + containerRect.height);\n\n      while (item && (itemRect.y - containerY) < pageY) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    }\n\n    return key ?? this.getLastKey();\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}