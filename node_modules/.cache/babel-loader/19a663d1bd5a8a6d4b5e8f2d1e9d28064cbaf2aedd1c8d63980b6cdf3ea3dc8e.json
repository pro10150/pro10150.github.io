{"ast":null,"code":"import _toConsumableArray from \"C:/Users/pk117/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nvar getChildKey = function getChildKey(child) {\n  return child.key || \"\";\n};\nfunction updateChildLookup(children, allChildren) {\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n    allChildren.set(key, child);\n  });\n}\nfunction onlyElements(children) {\n  var filtered = [];\n  // We use forEach here instead of map as map mutates the component key by preprending `.$`\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\nvar AnimatePresence = function AnimatePresence(_ref) {\n  var children = _ref.children,\n    custom = _ref.custom,\n    _ref$initial = _ref.initial,\n    initial = _ref$initial === void 0 ? true : _ref$initial,\n    onExitComplete = _ref.onExitComplete,\n    exitBeforeEnter = _ref.exitBeforeEnter,\n    _ref$presenceAffectsL = _ref.presenceAffectsLayout,\n    presenceAffectsLayout = _ref$presenceAffectsL === void 0 ? true : _ref$presenceAffectsL,\n    _ref$mode = _ref.mode,\n    mode = _ref$mode === void 0 ? \"sync\" : _ref$mode;\n  invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n  // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n  var forceRender = useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];\n  var isMounted = useIsMounted();\n  // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n  var filteredChildren = onlyElements(children);\n  var childrenToRender = filteredChildren;\n  var exitingChildren = useRef(new Map()).current;\n  // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n  var presentChildren = useRef(childrenToRender);\n  // A lookup table to quickly reference components by key\n  var allChildren = useRef(new Map()).current;\n  // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n  var isInitialRender = useRef(true);\n  useIsomorphicLayoutEffect(function () {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  useUnmountEffect(function () {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exitingChildren.clear();\n  });\n  if (isInitialRender.current) {\n    return React.createElement(React.Fragment, null, childrenToRender.map(function (child) {\n      return React.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode\n      }, child);\n    }));\n  }\n  // If this is a subsequent render, deal with entering and exiting children\n  childrenToRender = _toConsumableArray(childrenToRender);\n  // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey);\n  // Diff the present children with our target children and mark those that are exiting\n  var numPresent = presentKeys.length;\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n    if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\n      exitingChildren.set(key, undefined);\n    }\n  }\n  // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n  if (mode === \"wait\" && exitingChildren.size) {\n    childrenToRender = [];\n  }\n  // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n  exitingChildren.forEach(function (component, key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n    var exitingComponent = component;\n    if (!exitingComponent) {\n      var onExit = function onExit() {\n        // clean up the exiting children map\n        exitingChildren.delete(key);\n        // compute the keys of children that were rendered once but are no longer present\n        // this could happen in case of too many fast consequent renderings\n        // @link https://github.com/framer/motion/issues/2023\n        var leftOverKeys = Array.from(allChildren.keys()).filter(function (childKey) {\n          return !targetKeys.includes(childKey);\n        });\n        // clean up the all children map\n        leftOverKeys.forEach(function (leftOverKey) {\n          return allChildren.delete(leftOverKey);\n        });\n        // make sure to render only the children that are actually visible\n        presentChildren.current = filteredChildren.filter(function (presentChild) {\n          var presentChildKey = getChildKey(presentChild);\n          return (\n            // filter out the node exiting\n            presentChildKey === key ||\n            // filter out the leftover children\n            leftOverKeys.includes(presentChildKey)\n          );\n        });\n        // Defer re-rendering until all exiting children have indeed left\n        if (!exitingChildren.size) {\n          if (isMounted.current === false) return;\n          forceRender();\n          onExitComplete && onExitComplete();\n        }\n      };\n      exitingComponent = React.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: false,\n        onExitComplete: onExit,\n        custom: custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode\n      }, child);\n      exitingChildren.set(key, exitingComponent);\n    }\n    childrenToRender.splice(insertionIndex, 0, exitingComponent);\n  });\n  // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exitingChildren.has(key) ? child : React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode\n    }, child);\n  });\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its mode is set to \\\"wait\\\". This will lead to odd visual behaviour.\");\n  }\n  return React.createElement(React.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\nexport { AnimatePresence };","map":{"version":3,"names":["React","useContext","useRef","cloneElement","Children","isValidElement","useForceUpdate","useIsMounted","PresenceChild","LayoutGroupContext","useIsomorphicLayoutEffect","useUnmountEffect","invariant","getChildKey","child","key","updateChildLookup","children","allChildren","forEach","set","onlyElements","filtered","push","AnimatePresence","_ref","custom","_ref$initial","initial","onExitComplete","exitBeforeEnter","_ref$presenceAffectsL","presenceAffectsLayout","_ref$mode","mode","forceRender","isMounted","filteredChildren","childrenToRender","exitingChildren","Map","current","presentChildren","isInitialRender","clear","createElement","Fragment","map","isPresent","undefined","_toConsumableArray","presentKeys","targetKeys","numPresent","length","i","indexOf","has","size","component","get","insertionIndex","exitingComponent","onExit","delete","leftOverKeys","Array","from","keys","filter","childKey","includes","leftOverKey","presentChild","presentChildKey","splice","process","env","NODE_ENV","console","warn"],"sources":["C:/Users/pk117/Desktop/Personal/pro10150.github.io/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["import * as React from 'react';\r\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\r\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\r\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\r\nimport { PresenceChild } from './PresenceChild.mjs';\r\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\r\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\r\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\r\nimport { invariant } from '../../utils/errors.mjs';\r\n\r\nconst getChildKey = (child) => child.key || \"\";\r\nfunction updateChildLookup(children, allChildren) {\r\n    children.forEach((child) => {\r\n        const key = getChildKey(child);\r\n        allChildren.set(key, child);\r\n    });\r\n}\r\nfunction onlyElements(children) {\r\n    const filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    Children.forEach(children, (child) => {\r\n        if (isValidElement(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = \"sync\", }) => {\r\n    invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\r\n    // We want to force a re-render once all exiting animations have finished. We\r\n    // either use a local forceRender function, or one from a parent context if it exists.\r\n    const forceRender = useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];\r\n    const isMounted = useIsMounted();\r\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\r\n    const filteredChildren = onlyElements(children);\r\n    let childrenToRender = filteredChildren;\r\n    const exitingChildren = useRef(new Map()).current;\r\n    // Keep a living record of the children we're actually rendering so we\r\n    // can diff to figure out which are entering and exiting\r\n    const presentChildren = useRef(childrenToRender);\r\n    // A lookup table to quickly reference components by key\r\n    const allChildren = useRef(new Map()).current;\r\n    // If this is the initial component render, just deal with logic surrounding whether\r\n    // we play onMount animations or not.\r\n    const isInitialRender = useRef(true);\r\n    useIsomorphicLayoutEffect(() => {\r\n        isInitialRender.current = false;\r\n        updateChildLookup(filteredChildren, allChildren);\r\n        presentChildren.current = childrenToRender;\r\n    });\r\n    useUnmountEffect(() => {\r\n        isInitialRender.current = true;\r\n        allChildren.clear();\r\n        exitingChildren.clear();\r\n    });\r\n    if (isInitialRender.current) {\r\n        return (React.createElement(React.Fragment, null, childrenToRender.map((child) => (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child)))));\r\n    }\r\n    // If this is a subsequent render, deal with entering and exiting children\r\n    childrenToRender = [...childrenToRender];\r\n    // Diff the keys of the currently-present and target children to update our\r\n    // exiting list.\r\n    const presentKeys = presentChildren.current.map(getChildKey);\r\n    const targetKeys = filteredChildren.map(getChildKey);\r\n    // Diff the present children with our target children and mark those that are exiting\r\n    const numPresent = presentKeys.length;\r\n    for (let i = 0; i < numPresent; i++) {\r\n        const key = presentKeys[i];\r\n        if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\r\n            exitingChildren.set(key, undefined);\r\n        }\r\n    }\r\n    // If we currently have exiting children, and we're deferring rendering incoming children\r\n    // until after all current children have exiting, empty the childrenToRender array\r\n    if (mode === \"wait\" && exitingChildren.size) {\r\n        childrenToRender = [];\r\n    }\r\n    // Loop through all currently exiting components and clone them to overwrite `animate`\r\n    // with any `exit` prop they might have defined.\r\n    exitingChildren.forEach((component, key) => {\r\n        // If this component is actually entering again, early return\r\n        if (targetKeys.indexOf(key) !== -1)\r\n            return;\r\n        const child = allChildren.get(key);\r\n        if (!child)\r\n            return;\r\n        const insertionIndex = presentKeys.indexOf(key);\r\n        let exitingComponent = component;\r\n        if (!exitingComponent) {\r\n            const onExit = () => {\r\n                // clean up the exiting children map\r\n                exitingChildren.delete(key);\r\n                // compute the keys of children that were rendered once but are no longer present\r\n                // this could happen in case of too many fast consequent renderings\r\n                // @link https://github.com/framer/motion/issues/2023\r\n                const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));\r\n                // clean up the all children map\r\n                leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));\r\n                // make sure to render only the children that are actually visible\r\n                presentChildren.current = filteredChildren.filter((presentChild) => {\r\n                    const presentChildKey = getChildKey(presentChild);\r\n                    return (\r\n                    // filter out the node exiting\r\n                    presentChildKey === key ||\r\n                        // filter out the leftover children\r\n                        leftOverKeys.includes(presentChildKey));\r\n                });\r\n                // Defer re-rendering until all exiting children have indeed left\r\n                if (!exitingChildren.size) {\r\n                    if (isMounted.current === false)\r\n                        return;\r\n                    forceRender();\r\n                    onExitComplete && onExitComplete();\r\n                }\r\n            };\r\n            exitingComponent = (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\r\n            exitingChildren.set(key, exitingComponent);\r\n        }\r\n        childrenToRender.splice(insertionIndex, 0, exitingComponent);\r\n    });\r\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\r\n    // the same tree between renders\r\n    childrenToRender = childrenToRender.map((child) => {\r\n        const key = child.key;\r\n        return exitingChildren.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\r\n    });\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        mode === \"wait\" &&\r\n        childrenToRender.length > 1) {\r\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\r\n    }\r\n    return (React.createElement(React.Fragment, null, exitingChildren.size\r\n        ? childrenToRender\r\n        : childrenToRender.map((child) => cloneElement(child))));\r\n};\r\n\r\nexport { AnimatePresence };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}